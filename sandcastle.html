<!DOCTYPE html>

<html lang="en">

<head>

  <meta charset="utf-8">

  <!-- Include the CesiumJS JavaScript and CSS files -->

  <script src="https://cesium.com/downloads/cesiumjs/releases/1.133/Build/Cesium/Cesium.js"></script>

  <link href="https://cesium.com/downloads/cesiumjs/releases/1.133/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    #cesiumContainer {
      width: calc(100% - 350px);
      height: 100vh;
      float: left;
    }

    .cesium-viewer-toolbar {
      position: absolute;
      top: 10px;
      left: 40px; /* Move right to make room for toggle */
      z-index: 100;
      transition: transform 0.3s ease;
    }

    .cesium-viewer-toolbar.hidden {
      transform: translateX(-100%);
    }

    .cesium-viewer-bottom {
      display: none !important;
    }

    #add-object-toolbar {
      position: absolute;
      top: 10px;
      right: 370px; /* 350px panel width + 20px gap */
      background: rgba(42, 42, 42, 0.9);
      padding: 10px;
      border-radius: 5px;
      z-index: 100;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    
    #modelSelect {
      background: #444;
      color: white;
      border: 1px solid #666;
      border-radius: 3px;
      padding: 8px 12px;
      font-family: inherit;
      font-size: 14px;
      cursor: pointer;
    }
    
    #modelSelect option {
      background: #444;
      color: white;
    }

    #objects-panel {
      width: 350px;
      height: 100vh;
      float: right;
      background: #2a2a2a;
      color: white;
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
      border-left: 1px solid #444;
    }

    #objects-panel h3 {
      margin-top: 0;
      margin-bottom: 15px;
      color: #fff;
      font-size: 18px;
    }

    .object-card {
      background: #363636;
      border: 1px solid #555;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }

    .object-card h4 {
      margin: 0 0 10px 0;
      color: #4a9eff;
      font-size: 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .object-info {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      font-size: 12px;
    }

    .object-info div {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
      border-bottom: 1px solid #444;
    }

    .object-info label {
      color: #aaa;
      font-weight: 500;
    }

    .object-info span {
      color: #fff;
      font-family: 'Courier New', monospace;
    }

    .editable {
      background: transparent;
      border: none;
      color: #fff;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      text-align: right;
      width: 80px;
    }

    .editable:focus {
      background: #444;
      outline: 1px solid #4a9eff;
    }

    .object-controls {
      display: flex;
      gap: 8px;
      margin-top: 10px;
    }

    .btn {
      background: #4a9eff;
      color: white;
      border: none;
      padding: 4px 8px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
    }

    .btn:hover {
      background: #3a8eef;
    }

    .btn.danger {
      background: #ff4757;
    }

    .btn.danger:hover {
      background: #ff3a4f;
    }

    .flight-planning {
      margin-top: 15px;
      padding-top: 10px;
      border-top: 1px solid #555;
    }

    .flight-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
      align-items: center;
    }

    .flight-status {
      font-size: 11px;
      color: #aaa;
      margin-left: 10px;
    }

    .waypoint-list {
      max-height: 120px;
      overflow-y: auto;
      background: #2a2a2a;
      border: 1px solid #555;
      border-radius: 3px;
      margin-top: 8px;
    }

    .waypoint-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 8px;
      border-bottom: 1px solid #444;
      font-size: 11px;
    }

    .waypoint-item:last-child {
      border-bottom: none;
    }

    .waypoint-coords {
      color: #4a9eff;
      font-family: 'Courier New', monospace;
    }

    .waypoint-controls {
      display: flex;
      gap: 4px;
    }

    .btn-small {
      background: #666;
      color: white;
      border: none;
      padding: 2px 6px;
      border-radius: 2px;
      cursor: pointer;
      font-size: 10px;
    }

    .btn-small:hover {
      background: #777;
    }

    .planning-mode {
      background: #2d4a2d !important;
      border-color: #4a9a4a !important;
    }

    .planning-mode h4 {
      color: #4a9a4a !important;
    }
  </style>

</head>

<body>

  <div id="cesiumContainer"></div>
  
  <div id="add-object-toolbar">
    <select id="modelSelect">
      <option value="">Add New Object</option>
    </select>
  </div>

  <div id="objects-panel">
    <h3>Active Objects</h3>
    <div style="margin-bottom: 15px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 5px;">
      <div style="display: flex; gap: 10px; margin-bottom: 8px;">
        <button class="btn" style="background: #28a745;" onclick="saveAllFlightPlans()">Save All Plans</button>
        <button class="btn" style="background: #17a2b8;" onclick="loadFlightPlans()">Load Plans</button>
      </div>
      <div style="font-size: 11px; color: #aaa;">Save/load flight plans for all objects with waypoints</div>
    </div>
    <div id="object-cards-container"></div>
  </div>

  <script type="module">
    // Multi-Object Tracking System
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJmNGU2YTQwYi05ZGFkLTQ5ZWYtOTJlNC0zY2EwNmUzZDA4MGYiLCJpZCI6MzM4ODAyLCJpYXQiOjE3NTcwOTUxMzd9.gDyQcH0fKKNQxGIQjzSyjbQt1tjWDERbZt4eUna9Xbc';

    // Initialize Cesium Viewer
    const viewer = new Cesium.Viewer("cesiumContainer", {
      shadows: true,
      shouldAnimate: true,
      timeline: true,
    });

    // Fly to San Francisco startup view
    viewer.camera.flyTo({
      destination: Cesium.Cartesian3.fromDegrees(-122.4175, 37.655, 400),
      orientation: {
        heading: Cesium.Math.toRadians(0.0),
        pitch: Cesium.Math.toRadians(-15.0),
      }
    });

    // Global object management
    let objects = [];
    let nextObjectId = 1;

    // Object styling configuration
    const ObjectStyleConfig = {
      countries: {
        "USA": {
          fontColor: "#0000FF",
          flightPathColor: "#0000FF"
        },
        "China": {
          fontColor: "#FF0000", 
          flightPathColor: "#FF0000"
        }
      },
      aircraftMapping: {
        "J-20 Mighty Dragon": "China",
        "F-35 Lightning II": "USA"
      },
      default: {
        fontColor: "#4a9eff",
        flightPathColor: "#00FFFF"
      }
    };

    // Function to determine country based on aircraft type
    function getCountryFromAircraftType(aircraftType) {
      for (const [aircraft, country] of Object.entries(ObjectStyleConfig.aircraftMapping)) {
        if (aircraftType.includes(aircraft)) {
          return country;
        }
      }
      return "USA"; // Default fallback
    }

    // Function to get styling for a country
    function getCountryStyle(country) {
      return ObjectStyleConfig.countries[country] || ObjectStyleConfig.default;
    }

    // Platform-specific turn rates (degrees per second)
    const PLATFORM_TURN_RATES = {
      'Fighter': 20,
      'Bomber': 8,
      'Transport': 5,
      'UAV': 15
    };

    // Object data structure
    class TrackedObject {
      constructor(type, modelUrl, platform, initialHeading = null) {
        this.id = nextObjectId++;
        this.type = type;
        this.modelUrl = modelUrl;
        this.platform = platform;
        this.turnRate = PLATFORM_TURN_RATES[platform] || 10; // degrees per second
        
        // Calculated from Cesium entity
        this.longitude = -122.4175 + (Math.random() - 0.5) * 0.1;
        this.latitude = 37.655 + (Math.random() - 0.5) * 0.1;
        this.altitude = 10000 + Math.random() * 20000;
        this.speed = 0;
        this.heading = initialHeading !== null ? initialHeading : Math.random() * 360; // Random heading 0-360 degrees
        this.pitch = 0;
        this.roll = 0;
        
        // Editable metadata - determine country from aircraft type
        this.country = getCountryFromAircraftType(type);
        this.callsign = `${type}${String(this.id).padStart(2, '0')}`;
        this.fuel = '75%';
        this.timeOnStation = '2h 15m';
        this.loadout = 'Standard';
        this.status = 'Active';
        this.mission = 'CAP';
        this.task = 'Patrol';
        this.flightPlan = 'None';
        
        // Flight planning
        this.waypoints = [];
        this.flightPath = null;
        this.isPlanning = false;
        this.isFlying = false;
        this.flightProgress = 0;
        this.flightSpeed = 250; // knots
        this.flightStartTime = null;
        
        this.entity = null;
        this.createEntity();
      }

      createEntity() {
        const position = Cesium.Cartesian3.fromDegrees(
          this.longitude,
          this.latitude,
          this.altitude
        );

        // Convert from true north (0Â° = north) to Cesium system (0Â° = east)
        // Subtract 90 degrees to convert from geographic heading to Cesium heading
        const cesiumHeading = this.heading - 90;
        const headingRadians = Cesium.Math.toRadians(cesiumHeading);
        const pitchRadians = Cesium.Math.toRadians(this.pitch);
        const rollRadians = Cesium.Math.toRadians(this.roll);
        const hpr = new Cesium.HeadingPitchRoll(headingRadians, pitchRadians, rollRadians);
        const orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);

        this.entity = viewer.entities.add({
          id: `object_${this.id}`,
          name: this.callsign,
          position: position,
          orientation: orientation,
          model: {
            uri: this.modelUrl,
            minimumPixelSize: 128,
            maximumScale: 20000,
          },
        });
      }

      updateCalculatedFields() {
        if (!this.entity) return;
        
        const currentTime = viewer.clock.currentTime;
        const position = this.entity.position.getValue(currentTime);
        let previousPosition = null;
        
        // Get previous position for speed calculation
        const previousTime = Cesium.JulianDate.addSeconds(currentTime, -1, new Cesium.JulianDate());
        try {
          previousPosition = this.entity.position.getValue(previousTime);
        } catch (e) {
          // Handle case where previous time is outside the sample range
          previousPosition = null;
        }
        
        if (position) {
          const cartographic = Cesium.Cartographic.fromCartesian(position);
          this.longitude = Cesium.Math.toDegrees(cartographic.longitude);
          this.latitude = Cesium.Math.toDegrees(cartographic.latitude);
          this.altitude = cartographic.height;
          
          // Calculate speed if we have a previous position
          if (previousPosition && this.isFlying) {
            const distance = Cesium.Cartesian3.distance(previousPosition, position);
            this.speed = distance * 1.94384; // Convert m/s to knots
          } else if (!this.isFlying) {
            this.speed = 0;
          }
        }

        // Extract current orientation from the dynamic flight animation
        if (this.isFlying && this.entity.orientation) {
          const orientation = this.entity.orientation.getValue(currentTime);
          if (orientation && position) {
            try {
              // Create the local reference frame at the aircraft's position
              const transform = Cesium.Transforms.eastNorthUpToFixedFrame(position);
              const transformMatrix = Cesium.Matrix4.getMatrix3(transform, new Cesium.Matrix3());
              
              // Convert quaternion to rotation matrix
              const orientationMatrix = Cesium.Matrix3.fromQuaternion(orientation);
              
              // Transform to local coordinate system
              const localMatrix = Cesium.Matrix3.multiply(
                Cesium.Matrix3.transpose(transformMatrix, new Cesium.Matrix3()),
                orientationMatrix,
                new Cesium.Matrix3()
              );
              
              // Extract Euler angles from the local rotation matrix
              // Using the ZYX rotation order (yaw-pitch-roll)
              const m = localMatrix;
              
              // Calculate pitch (rotation about Y axis)
              const pitch = Math.asin(-m[6]); // -sin(pitch) = -m[2][0]
              
              // Calculate heading (rotation about Z axis)  
              let heading = Math.atan2(m[3], m[0]); // atan2(sin(yaw), cos(yaw))
              
              // Calculate roll (rotation about X axis)
              const roll = Math.atan2(m[7], m[8]); // atan2(sin(roll), cos(roll))
              
              // Convert to degrees and adjust coordinate system
              this.heading = (Cesium.Math.toDegrees(heading) + 90 + 360) % 360;
              this.pitch = Cesium.Math.toDegrees(pitch);
              this.roll = Cesium.Math.toDegrees(roll);
              
            } catch (e) {
              console.error('Error extracting orientation:', e);
              // Keep existing values if calculation fails
            }
          }
        }
        
        // Update flight-specific data
        if (this.isFlying) {
          this.updateFlightData();
        }
      }
      
      updateFlightData() {
        if (!this.flightStartTime) return;
        
        const elapsedTime = (Date.now() - this.flightStartTime) / 1000; // seconds
        const elapsedMinutes = Math.floor(elapsedTime / 60);
        const elapsedSeconds = Math.floor(elapsedTime % 60);
        
        // Update time on station (flight time)
        this.timeOnStation = `${elapsedMinutes}m ${elapsedSeconds}s`;
        
        // Simple fuel consumption model (1% per minute of flight)
        if (this.originalFuel === undefined) {
          this.originalFuel = parseFloat(this.fuel.replace('%', '')) || 75;
        }
        
        const fuelConsumptionRate = 1.0; // 1% per minute
        const consumedFuel = (elapsedMinutes * fuelConsumptionRate);
        const remainingFuel = Math.max(0, this.originalFuel - consumedFuel);
        this.fuel = `${remainingFuel.toFixed(0)}%`;
        
        // Update status based on flight progress
        if (remainingFuel <= 10) {
          this.status = 'Low Fuel';
        } else if (remainingFuel <= 25) {
          this.status = 'Fuel Warning';
        } else {
          this.status = 'Flying';
        }
      }

      addWaypoint(longitude, latitude, altitude) {
        this.waypoints.push({
          longitude: longitude,
          latitude: latitude,
          altitude: altitude || 0, // Default altitude set to 0
          speed: this.flightSpeed || 250, // Default speed in knots
          heading: undefined, // Auto-calculate heading
          id: Date.now()
        });
        this.updateFlightPath();
        // Force card regeneration when waypoints change
        setTimeout(() => updateObjectCards(), 100);
      }

      removeWaypoint(waypointId) {
        this.waypoints = this.waypoints.filter(wp => wp.id !== waypointId);
        this.updateFlightPath();
        // Force card regeneration when waypoints change
        setTimeout(() => updateObjectCards(), 100);
      }

      updateFlightPath() {
        if (this.flightPath) {
          viewer.entities.remove(this.flightPath);
          this.flightPath = null;
        }

        if (this.waypoints.length > 1) {
          const positions = this.waypoints.map(wp => 
            Cesium.Cartesian3.fromDegrees(wp.longitude, wp.latitude, wp.altitude)
          );

          // Get country-specific color for flight path
          const countryStyle = getCountryStyle(this.country);
          const flightPathColor = Cesium.Color.fromCssColorString(countryStyle.flightPathColor);

          this.flightPath = viewer.entities.add({
            id: `flightPath_${this.id}`,
            name: `${this.callsign} Flight Path`,
            polyline: {
              positions: positions,
              width: 3,
              material: flightPathColor,
              clampToGround: false,
              followSurface: false,
            }
          });
        }
      }

      startFlight() {
        if (this.waypoints.length < 2) return;
        
        this.isFlying = true;
        this.flightProgress = 0;
        this.flightStartTime = Date.now();
        
        // Store original fuel level for consumption tracking
        if (this.originalFuel === undefined) {
          this.originalFuel = parseFloat(this.fuel.replace('%', '')) || 75;
        }

        // Create flight animation with per-waypoint speeds
        const positions = this.waypoints.map(wp => 
          Cesium.Cartesian3.fromDegrees(wp.longitude, wp.latitude, wp.altitude)
        );

        // Calculate time for each leg based on waypoint speeds
        const flightData = [];
        let cumulativeTime = this.flightStartTime;
        
        for (let i = 0; i < this.waypoints.length; i++) {
          const waypoint = this.waypoints[i];
          
          if (i > 0) {
            // Calculate distance to this waypoint from previous
            const prevPos = positions[i - 1];
            const currentPos = positions[i];
            const segmentDistance = Cesium.Cartesian3.distance(prevPos, currentPos) / 1000; // km
            
            // Use waypoint's speed (or default speed) to calculate time
            const waypointSpeed = waypoint.speed || this.flightSpeed || 250; // knots
            const speedKmh = waypointSpeed * 1.852; // Convert knots to km/h
            const segmentTimeHours = segmentDistance / speedKmh;
            const segmentTimeMs = segmentTimeHours * 3600 * 1000; // Convert to milliseconds
            
            cumulativeTime += segmentTimeMs;
          }
          
          // Use waypoint heading if specified, otherwise calculate
          let heading = 0;
          let pitch = 0;
          let roll = 0; // Banking angle
          
          if (waypoint.heading !== undefined) {
            // Use specified heading
            heading = Cesium.Math.toRadians(waypoint.heading);
          } else {
            // Calculate heading towards next waypoint
            if (i < this.waypoints.length - 1) {
              const currentPos = positions[i];
              const nextPos = positions[i + 1];
              
              // Calculate bearing between points (geographic bearing)
              const currentCart = Cesium.Cartographic.fromCartesian(currentPos);
              const nextCart = Cesium.Cartographic.fromCartesian(nextPos);
              
              const deltaLon = nextCart.longitude - currentCart.longitude;
              const lat1 = currentCart.latitude;
              const lat2 = nextCart.latitude;
              
              const y = Math.sin(deltaLon) * Math.cos(lat2);
              const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLon);
              
              // Geographic bearing (0 = north)
              heading = Math.atan2(y, x);
            } else {
              // Last waypoint - maintain previous heading
              if (flightData.length > 0) {
                heading = flightData[flightData.length - 1].heading;
              } else {
                heading = Cesium.Math.toRadians(this.heading);
              }
            }
          }
          
          // Calculate pitch based on altitude change
          if (i < this.waypoints.length - 1) {
            const currentPos = positions[i];
            const nextPos = positions[i + 1];
            const currentCart = Cesium.Cartographic.fromCartesian(currentPos);
            const nextCart = Cesium.Cartographic.fromCartesian(nextPos);
            
            const currentAlt = currentCart.height;
            const nextAlt = nextCart.height;
            const distance = Cesium.Cartesian3.distance(currentPos, nextPos);
            const altitudeChange = nextAlt - currentAlt;
            pitch = Math.atan2(altitudeChange, distance);
          } else {
            pitch = 0;
          }
          
          flightData.push({
            time: cumulativeTime,
            position: positions[i],
            heading: heading,
            pitch: pitch,
            roll: roll
          });
        }

        // Calculate lead-turn points for each waypoint using actual waypoint positions (MUST be before enhanced flight path)
        const leadTurnData = [];
        for (let i = 1; i < this.waypoints.length - 1; i++) {
          const inboundWP = this.waypoints[i - 1];
          const turnWP = this.waypoints[i];
          const outboundWP = this.waypoints[i + 1];
          
          // Calculate actual course headings from waypoint positions
          const inboundCart = Cesium.Cartographic.fromDegrees(inboundWP.longitude, inboundWP.latitude);
          const turnCart = Cesium.Cartographic.fromDegrees(turnWP.longitude, turnWP.latitude);
          const outboundCart = Cesium.Cartographic.fromDegrees(outboundWP.longitude, outboundWP.latitude);
          
          // Inbound course (approaching turnWP)
          const inboundDeltaLon = turnCart.longitude - inboundCart.longitude;
          const inboundY = Math.sin(inboundDeltaLon) * Math.cos(turnCart.latitude);
          const inboundX = Math.cos(inboundCart.latitude) * Math.sin(turnCart.latitude) - 
                          Math.sin(inboundCart.latitude) * Math.cos(turnCart.latitude) * Math.cos(inboundDeltaLon);
          const inboundCourse = Math.atan2(inboundY, inboundX);
          
          // Outbound course (departing turnWP)
          const outboundDeltaLon = outboundCart.longitude - turnCart.longitude;
          const outboundY = Math.sin(outboundDeltaLon) * Math.cos(outboundCart.latitude);
          const outboundX = Math.cos(turnCart.latitude) * Math.sin(outboundCart.latitude) - 
                           Math.sin(turnCart.latitude) * Math.cos(outboundCart.latitude) * Math.cos(outboundDeltaLon);
          const outboundCourse = Math.atan2(outboundY, outboundX);
          
          // Calculate heading change needed
          let headingChange = outboundCourse - inboundCourse;
          while (headingChange > Math.PI) headingChange -= 2 * Math.PI;
          while (headingChange < -Math.PI) headingChange += 2 * Math.PI;
          
          if (Math.abs(headingChange) > 0.01) {
            const headingChangeDegrees = Math.abs(Cesium.Math.toDegrees(headingChange));
            
            // For turns â‰¥90Â°, split into two steps to prevent abrupt heading changes
            if (headingChangeDegrees >= 90) {
              // Step 1: Turn 89Â° toward target
              const firstTurnDegrees = 89;
              const firstTurnRadians = Math.sign(headingChange) * Cesium.Math.toRadians(firstTurnDegrees);
              const firstTurnDuration = firstTurnDegrees / this.turnRate; // seconds
              
              // Step 2: Complete remaining turn
              const remainingTurnDegrees = headingChangeDegrees - firstTurnDegrees;
              const remainingTurnRadians = Math.sign(headingChange) * Cesium.Math.toRadians(remainingTurnDegrees);
              const remainingTurnDuration = remainingTurnDegrees / this.turnRate; // seconds
              
              const totalTurnDuration = firstTurnDuration + remainingTurnDuration;
              
              // Calculate intermediate heading after first 89Â° turn
              const intermediateHeading = inboundCourse + firstTurnRadians;
              
              // Calculate lead time for the entire two-step turn
              const leadTime = totalTurnDuration * 0.5;
              const turnWPTime = flightData[i].time;
              const leadTurnStartTime = turnWPTime - (leadTime * 1000);
              
              // First turn phase
              leadTurnData.push({
                waypointIndex: i,
                leadTurnStartTime: leadTurnStartTime,
                turnDuration: firstTurnDuration * 1000, // Convert to milliseconds
                headingChange: firstTurnRadians,
                inboundCourse: inboundCourse,
                outboundCourse: intermediateHeading,
                turnWaypoint: turnWP,
                nextWaypoint: outboundWP,
                isFirstPhase: true,
                totalTurnPhases: 2
              });
              
              // Second turn phase (starts immediately after first phase)
              leadTurnData.push({
                waypointIndex: i,
                leadTurnStartTime: leadTurnStartTime + (firstTurnDuration * 1000),
                turnDuration: remainingTurnDuration * 1000, // Convert to milliseconds
                headingChange: remainingTurnRadians,
                inboundCourse: intermediateHeading,
                outboundCourse: outboundCourse,
                turnWaypoint: turnWP,
                nextWaypoint: outboundWP,
                isSecondPhase: true,
                totalTurnPhases: 2
              });
              
            } else {
              // Single-step turn for turns <90Â°
              const turnDuration = headingChangeDegrees / this.turnRate; // seconds
              
              // Calculate lead time needed to complete turn by waypoint
              const leadTime = turnDuration * 0.5; // Start turn halfway before waypoint arrival
              const turnWPTime = flightData[i].time;
              const leadTurnStartTime = turnWPTime - (leadTime * 1000); // Convert to milliseconds
              
              leadTurnData.push({
                waypointIndex: i,
                leadTurnStartTime: leadTurnStartTime,
                turnDuration: turnDuration * 1000, // Convert to milliseconds
                headingChange: headingChange,
                inboundCourse: inboundCourse,
                outboundCourse: outboundCourse,
                turnWaypoint: turnWP,
                nextWaypoint: outboundWP
              });
            }
          }
        }

        // Create enhanced flight path with realistic turn geometry
        const enhancedFlightData = [];
        
        for (let i = 0; i < flightData.length - 1; i++) {
          const currentWP = flightData[i];
          const nextWP = flightData[i + 1];
          
          enhancedFlightData.push(currentWP);
          
          // Add intermediate points for realistic turn geometry
          const segmentTime = nextWP.time - currentWP.time;
          const numIntermediate = Math.max(1, Math.floor(segmentTime / (5 * 1000))); // One point every 5 seconds
          
          for (let j = 1; j < numIntermediate; j++) {
            const factor = j / numIntermediate;
            const intermediateTime = currentWP.time + (segmentTime * factor);
            
            // Check if this time falls within any turn
            let inTurn = false;
            let turnData = null;
            for (const turn of leadTurnData) {
              if (intermediateTime >= turn.leadTurnStartTime && 
                  intermediateTime <= turn.leadTurnStartTime + turn.turnDuration) {
                inTurn = true;
                turnData = turn;
                break;
              }
            }
            
            let intermediatePosition;
            if (inTurn && turnData) {
              // Calculate curved path during turn
              const turnProgress = (intermediateTime - turnData.leadTurnStartTime) / turnData.turnDuration;
              const clampedProgress = Math.max(0, Math.min(1, turnProgress));
              
              // Create an arc instead of straight line
              const centerFactor = 0.5; // Arc peak at midpoint
              const arcHeight = Math.abs(turnData.headingChange) * 1000; // Arc height based on turn angle
              const arcOffset = Math.sin(clampedProgress * Math.PI) * arcHeight;
              
              // Base position from linear interpolation
              const basePosition = new Cesium.Cartesian3();
              Cesium.Cartesian3.lerp(currentWP.position, nextWP.position, factor, basePosition);
              
              // Add perpendicular offset for turn arc
              const currentCart = Cesium.Cartographic.fromCartesian(currentWP.position);
              const nextCart = Cesium.Cartographic.fromCartesian(nextWP.position);
              
              // Calculate perpendicular direction (simplified for small distances)
              const bearing = Math.atan2(
                Math.sin(nextCart.longitude - currentCart.longitude) * Math.cos(nextCart.latitude),
                Math.cos(currentCart.latitude) * Math.sin(nextCart.latitude) - 
                Math.sin(currentCart.latitude) * Math.cos(nextCart.latitude) * Math.cos(nextCart.longitude - currentCart.longitude)
              );
              
              const perpBearing = bearing + (Math.sign(turnData.headingChange) * Math.PI / 2);
              const offsetLat = currentCart.latitude + (arcOffset * Math.cos(perpBearing)) / 111000;
              const offsetLon = currentCart.longitude + (arcOffset * Math.sin(perpBearing)) / (111000 * Math.cos(currentCart.latitude));
              
              intermediatePosition = Cesium.Cartesian3.fromDegrees(
                Cesium.Math.toDegrees(offsetLon),
                Cesium.Math.toDegrees(offsetLat),
                currentCart.height + (nextCart.height - currentCart.height) * factor
              );
            } else {
              // Straight line interpolation when not turning
              intermediatePosition = new Cesium.Cartesian3();
              Cesium.Cartesian3.lerp(currentWP.position, nextWP.position, factor, intermediatePosition);
            }
            
            enhancedFlightData.push({
              time: intermediateTime,
              position: intermediatePosition,
              heading: currentWP.heading + (nextWP.heading - currentWP.heading) * factor,
              pitch: currentWP.pitch + (nextWP.pitch - currentWP.pitch) * factor,
              roll: 0 // Will be calculated by orientation property
            });
          }
        }
        
        // Add final waypoint
        enhancedFlightData.push(flightData[flightData.length - 1]);
        
        // Create position property with enhanced flight path
        const positionProperty = new Cesium.SampledPositionProperty();
        for (let i = 0; i < enhancedFlightData.length; i++) {
          positionProperty.addSample(
            Cesium.JulianDate.fromDate(new Date(enhancedFlightData[i].time)), 
            enhancedFlightData[i].position
          );
        }
        
        positionProperty.setInterpolationOptions({
          interpolationDegree: 1, // Linear interpolation for smoother curves
          interpolationAlgorithm: Cesium.LinearApproximation
        });

        // Create dynamic orientation using CallbackProperty with lead-turning
        const orientationProperty = new Cesium.CallbackProperty((time, result) => {
          const currentTime = Cesium.JulianDate.toDate(time).getTime();
          let flightPoint = flightData[0];
          
          // Find current position in flight plan
          for (let i = 1; i < flightData.length; i++) {
            if (currentTime <= flightData[i].time) {
              const t1 = flightData[i - 1].time;
              const t2 = flightData[i].time;
              const factor = (currentTime - t1) / (t2 - t1);
              
              const h1 = flightData[i - 1].heading;
              const h2 = flightData[i].heading;
              const p1 = flightData[i - 1].pitch;
              const p2 = flightData[i].pitch;
              
              // Check if we're in a lead-turn
              let inTurn = false;
              let turnData = null;
              
              for (const turn of leadTurnData) {
                if (currentTime >= turn.leadTurnStartTime && 
                    currentTime <= turn.leadTurnStartTime + turn.turnDuration) {
                  inTurn = true;
                  turnData = turn;
                  break;
                }
              }
              
              let dynamicHeading, dynamicRoll;
              
              if (inTurn && turnData) {
                // We're in a lead-turn - turn to the outbound course
                const targetHeading = turnData.outboundCourse;
                const startHeading = turnData.inboundCourse;
                const headingChange = turnData.headingChange;
                
                // Calculate turn progress
                const turnProgress = (currentTime - turnData.leadTurnStartTime) / turnData.turnDuration;
                const clampedProgress = Math.max(0, Math.min(1, turnProgress));
                
                // Linear progression toward outbound course (no overshoot)
                dynamicHeading = startHeading + headingChange * clampedProgress;
                
                // Ensure we NEVER overshoot the outbound course
                if (Math.abs(headingChange) > 0) {
                  if (headingChange > 0) {
                    // Right turn - don't exceed outbound course
                    dynamicHeading = Math.min(dynamicHeading, targetHeading);
                  } else {
                    // Left turn - don't exceed outbound course
                    dynamicHeading = Math.max(dynamicHeading, targetHeading);
                  }
                }
                
                // Normalize dynamic heading
                while (dynamicHeading > Math.PI) dynamicHeading -= 2 * Math.PI;
                while (dynamicHeading < -Math.PI) dynamicHeading += 2 * Math.PI;
                
                // Calculate how much of the turn we've completed
                let actualHeadingChange = dynamicHeading - startHeading;
                while (actualHeadingChange > Math.PI) actualHeadingChange -= 2 * Math.PI;
                while (actualHeadingChange < -Math.PI) actualHeadingChange += 2 * Math.PI;
                
                const headingProgress = Math.abs(actualHeadingChange / headingChange);
                const clampedHeadingProgress = Math.max(0, Math.min(1, headingProgress));
                
                // Banking synchronized with heading progress
                let bankingFactor;
                if (clampedHeadingProgress <= 0.5) {
                  // First half of turn: build banking
                  bankingFactor = Math.sin(clampedHeadingProgress * Math.PI); // 0 to 1
                } else {
                  // Second half of turn: decrease banking to zero
                  bankingFactor = Math.sin((1 - clampedHeadingProgress) * Math.PI); // 1 to 0
                }
                
                const turnIntensity = Math.abs(Cesium.Math.toDegrees(headingChange));
                const maxBankAngle = Cesium.Math.toRadians(Math.min(turnIntensity, 60));
                dynamicRoll = Math.sign(headingChange) * maxBankAngle * bankingFactor;
                
                // Stop turning when we reach the outbound course
                const headingDifference = Math.abs(dynamicHeading - targetHeading);
                if (headingDifference < 0.01) { // Within ~0.5 degrees
                  dynamicRoll = 0;
                  dynamicHeading = targetHeading;
                }
                
              } else {
                // Not in turn - fly straight on current leg's course
                // Find which leg we're on and use its course
                dynamicHeading = h1;
                dynamicRoll = 0;
                
                // If we're between waypoints, use the direct course between them
                for (let j = 0; j < this.waypoints.length - 1; j++) {
                  const legStart = flightData[j];
                  const legEnd = flightData[j + 1];
                  
                  if (currentTime >= legStart.time && currentTime <= legEnd.time) {
                    // Calculate direct course for this leg
                    const startWP = this.waypoints[j];
                    const endWP = this.waypoints[j + 1];
                    
                    const startCart = Cesium.Cartographic.fromDegrees(startWP.longitude, startWP.latitude);
                    const endCart = Cesium.Cartographic.fromDegrees(endWP.longitude, endWP.latitude);
                    
                    const deltaLon = endCart.longitude - startCart.longitude;
                    const y = Math.sin(deltaLon) * Math.cos(endCart.latitude);
                    const x = Math.cos(startCart.latitude) * Math.sin(endCart.latitude) - 
                             Math.sin(startCart.latitude) * Math.cos(endCart.latitude) * Math.cos(deltaLon);
                    
                    dynamicHeading = Math.atan2(y, x);
                    break;
                  }
                }
              }
              
              flightPoint = {
                heading: dynamicHeading,
                pitch: p1 + (p2 - p1) * factor,
                roll: dynamicRoll,
                position: flightData[i - 1].position
              };
              break;
            }
            flightPoint = flightData[i];
          }
          
          // Convert from geographic to Cesium coordinate system
          const cesiumHeading = flightPoint.heading - Math.PI / 2; // Subtract 90 degrees
          
          // Create quaternion from heading, pitch, roll
          return Cesium.Transforms.headingPitchRollQuaternion(
            flightPoint.position,
            new Cesium.HeadingPitchRoll(cesiumHeading, flightPoint.pitch, flightPoint.roll),
            Cesium.Ellipsoid.WGS84,
            Cesium.Transforms.eastNorthUpToFixedFrame,
            result
          );
        }, false);

        // Apply to entity
        this.entity.position = positionProperty;
        this.entity.orientation = orientationProperty;
        
        // Update flight plan status
        this.flightPlan = `Flying (${this.waypoints.length} waypoints)`;
      }

      stopFlight() {
        this.isFlying = false;
        this.flightProgress = 0;
        this.flightStartTime = null;
        
        // Reset flight data
        if (this.originalFuel !== undefined) {
          this.fuel = `${this.originalFuel}%`;
          this.originalFuel = undefined;
        }
        this.timeOnStation = '0m 0s';
        this.status = 'Active';
        this.speed = 0;
        
        // Reset to original position and orientation
        const position = Cesium.Cartesian3.fromDegrees(
          this.longitude,
          this.latitude,
          this.altitude
        );
        
        // Convert from true north (0Â° = north) to Cesium system (0Â° = east)
        const cesiumHeading = this.heading - 90;
        const headingRadians = Cesium.Math.toRadians(cesiumHeading);
        const pitchRadians = Cesium.Math.toRadians(this.pitch);
        const rollRadians = Cesium.Math.toRadians(this.roll);
        const hpr = new Cesium.HeadingPitchRoll(headingRadians, pitchRadians, rollRadians);
        const orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);
        
        this.entity.position = position;
        this.entity.orientation = orientation;
        this.flightPlan = `Planned (${this.waypoints.length} waypoints)`;
      }

      calculateTotalDistance() {
        let totalDistance = 0;
        for (let i = 1; i < this.waypoints.length; i++) {
          const prev = this.waypoints[i - 1];
          const curr = this.waypoints[i];
          
          const distance = Cesium.Cartesian3.distance(
            Cesium.Cartesian3.fromDegrees(prev.longitude, prev.latitude, prev.altitude),
            Cesium.Cartesian3.fromDegrees(curr.longitude, curr.latitude, curr.altitude)
          );
          
          totalDistance += distance;
        }
        return totalDistance / 1852; // Convert to nautical miles
      }

      clearFlightPlan() {
        this.stopFlight();
        this.waypoints = [];
        if (this.flightPath) {
          viewer.entities.remove(this.flightPath);
          this.flightPath = null;
        }
        this.flightPlan = 'None';
      }

      remove() {
        if (this.entity) {
          viewer.entities.remove(this.entity);
        }
        if (this.flightPath) {
          viewer.entities.remove(this.flightPath);
        }
      }
    }

    // Object card HTML generation
    function createObjectCard(obj) {
      // Get country-specific styling
      const countryStyle = getCountryStyle(obj.country);
      
      return `
        <div class="object-card" id="card_${obj.id}" data-object-id="${obj.id}">
          <h4 style="color: ${countryStyle.fontColor};">
            ${obj.callsign} (${obj.type})
            <span style="font-size: 12px; color: #aaa;">#${obj.id}</span>
          </h4>
          
          <div class="object-info">
            <div>
              <label>Country:</label>
              <input class="editable" value="${obj.country}" onchange="updateObjectField(${obj.id}, 'country', this.value)">
            </div>
            <div>
              <label>Platform:</label>
              <span>${obj.platform}</span>
            </div>
            <div>
              <label>Longitude:</label>
              <span class="longitude">${obj.longitude.toFixed(6)}Â°</span>
            </div>
            <div>
              <label>Latitude:</label>
              <span class="latitude">${obj.latitude.toFixed(6)}Â°</span>
            </div>
            <div>
              <label>Speed:</label>
              <span class="speed">${obj.speed.toFixed(0)} kts</span>
            </div>
            <div>
              <label>Altitude:</label>
              <span class="altitude">${(obj.altitude * 3.28084).toFixed(0)} ft</span>
            </div>
            <div>
              <label>Heading:</label>
              <span class="heading">${obj.heading.toFixed(0)}Â°</span>
            </div>
            <div>
              <label>Pitch:</label>
              <span class="pitch">${obj.pitch.toFixed(1)}Â°</span>
            </div>
            <div>
              <label>Bank:</label>
              <span class="roll">${obj.roll.toFixed(1)}Â°</span>
            </div>
            <div>
              <label>Fuel:</label>
              <input class="editable" value="${obj.fuel}" onchange="updateObjectField(${obj.id}, 'fuel', this.value)">
            </div>
            <div>
              <label>Time on Station:</label>
              <input class="editable" value="${obj.timeOnStation}" onchange="updateObjectField(${obj.id}, 'timeOnStation', this.value)">
            </div>
            <div>
              <label>Status:</label>
              <input class="editable" value="${obj.status}" onchange="updateObjectField(${obj.id}, 'status', this.value)">
            </div>
            <div>
              <label>Mission:</label>
              <input class="editable" value="${obj.mission}" onchange="updateObjectField(${obj.id}, 'mission', this.value)">
            </div>
            <div>
              <label>Task:</label>
              <input class="editable" value="${obj.task}" onchange="updateObjectField(${obj.id}, 'task', this.value)">
            </div>
            <div>
              <label>Loadout:</label>
              <input class="editable" value="${obj.loadout}" onchange="updateObjectField(${obj.id}, 'loadout', this.value)">
            </div>
            <div style="grid-column: span 2;">
              <label>Flight Plan:</label>
              <input class="editable" style="width: 150px;" value="${obj.flightPlan}" onchange="updateObjectField(${obj.id}, 'flightPlan', this.value)">
            </div>
          </div>

          <div class="object-controls">
            <button class="btn" onclick="focusObject(${obj.id})">Focus</button>
            <button class="btn" onclick="trackObject(${obj.id})">Track</button>
            <button class="btn" onclick="duplicateObject(${obj.id})">Duplicate</button>
            <button class="btn danger" onclick="removeObject(${obj.id})">Remove</button>
          </div>

          <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #555;">
            <div style="color: #ff6b6b; font-size: 11px; margin-bottom: 8px;">ðŸ”§ DEBUG CONTROLS</div>
            <div class="object-controls">
              <button class="btn" style="background: #ff6b6b;" onclick="testBankAngle(${obj.id})">Bank 30Â°</button>
              <button class="btn" style="background: #4ecdc4;" onclick="testAltitude(${obj.id})">Alt 30K ft</button>
              <button class="btn" style="background: #45b7d1;" onclick="testReset(${obj.id})">Reset</button>
            </div>
          </div>

          <div class="flight-planning">
            <div class="flight-controls">
              <button class="btn ${obj.isPlanning ? 'danger' : ''}" onclick="toggleFlightPlanning(${obj.id})">
                ${obj.isPlanning ? 'Stop Planning' : 'Plan Flight'}
              </button>
              ${obj.waypoints.length >= 2 ? `
                <button class="btn" onclick="${obj.isFlying ? 'stopFlight' : 'startFlight'}(${obj.id})">
                  ${obj.isFlying ? 'Stop Flight' : 'Start Flight'}
                </button>
              ` : ''}
              ${obj.waypoints.length > 0 ? `
                <button class="btn-small danger" onclick="clearFlightPlan(${obj.id})">Clear</button>
              ` : ''}
              <span class="flight-status">${obj.isFlying ? 'FLYING' : obj.isPlanning ? 'PLANNING' : 'READY'}</span>
            </div>
            
            ${obj.waypoints.length > 0 ? `
              <div class="waypoint-list">
                ${obj.waypoints.map((wp, index) => `
                  <div class="waypoint-item">
                    <div style="flex: 1;">
                      <div style="color: #4a9eff; font-family: 'Courier New', monospace; font-size: 11px; margin-bottom: 4px;">
                        WP${index + 1}: ${wp.longitude.toFixed(4)}Â°, ${wp.latitude.toFixed(4)}Â°
                      </div>
                      <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; margin-bottom: 2px;">
                        <div style="display: flex; align-items: center; gap: 2px;">
                          <span style="color: #aaa; font-size: 10px;">Alt:</span>
                          <input class="editable" style="width: 45px; font-size: 10px;" 
                                 value="${(wp.altitude * 3.28084).toFixed(0)}" 
                                 onchange="updateWaypointAltitude(${obj.id}, ${wp.id}, this.value)"
                                 placeholder="ft">
                          <span style="color: #aaa; font-size: 9px;">ft</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 2px;">
                          <span style="color: #aaa; font-size: 10px;">Spd:</span>
                          <input class="editable" style="width: 45px; font-size: 10px;" 
                                 value="${wp.speed || obj.flightSpeed || 250}" 
                                 onchange="updateWaypointSpeed(${obj.id}, ${wp.id}, this.value)"
                                 placeholder="kts">
                          <span style="color: #aaa; font-size: 9px;">kt</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 2px;">
                          <span style="color: #aaa; font-size: 10px;">Hdg:</span>
                          <input class="editable" style="width: 45px; font-size: 10px;" 
                                 value="${wp.heading !== undefined ? wp.heading.toFixed(0) : 'Auto'}" 
                                 onchange="updateWaypointHeading(${obj.id}, ${wp.id}, this.value)"
                                 placeholder="deg">
                          <span style="color: #aaa; font-size: 9px;">Â°</span>
                        </div>
                      </div>
                    </div>
                    <div class="waypoint-controls">
                      <button class="btn-small danger" onclick="removeWaypoint(${obj.id}, ${wp.id})">Ã—</button>
                    </div>
                  </div>
                `).join('')}
              </div>
            ` : ''}
          </div>
        </div>
      `;
    }

    // Object management functions
    function addObject(type, modelUrl, platform) {
      // Prompt for initial heading
      const headingInput = prompt(`Enter initial heading for ${type} (0-360 degrees):`, Math.floor(Math.random() * 360));
      let initialHeading = null;
      
      if (headingInput !== null) {
        const heading = parseFloat(headingInput);
        if (!isNaN(heading)) {
          initialHeading = ((heading % 360) + 360) % 360; // Normalize to 0-360
        }
      }
      
      const obj = new TrackedObject(type, modelUrl, platform, initialHeading);
      objects.push(obj);
      updateObjectCards();
    }

    function removeObject(id) {
      const index = objects.findIndex(obj => obj.id === id);
      if (index !== -1) {
        objects[index].remove();
        objects.splice(index, 1);
        updateObjectCards();
      }
    }

    function duplicateObject(id) {
      const original = objects.find(obj => obj.id === id);
      if (original) {
        addObject(original.type, original.modelUrl, original.platform);
      }
    }

    function focusObject(id) {
      const obj = objects.find(obj => obj.id === id);
      if (obj && obj.entity) {
        viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(
            obj.longitude,
            obj.latitude,
            obj.altitude + 5000
          )
        });
      }
    }

    function trackObject(id) {
      const obj = objects.find(obj => obj.id === id);
      if (obj && obj.entity) {
        viewer.trackedEntity = obj.entity;
      }
    }

    function updateObjectField(id, field, value) {
      const obj = objects.find(obj => obj.id === id);
      if (obj) {
        obj[field] = value;
        if (field === 'callsign' && obj.entity) {
          obj.entity.name = value;
        }
      }
    }

    function updateObjectCards() {
      const container = document.getElementById('object-cards-container');
      container.innerHTML = objects.map(obj => createObjectCard(obj)).join('');
    }

    // Update only dynamic data without regenerating HTML (prevents input field resets)
    function updateObjectData() {
      objects.forEach(obj => {
        const card = document.querySelector(`[data-object-id="${obj.id}"]`);
        if (!card) return;

        // Update span elements (display data)
        const updateSpan = (selector, value) => {
          const element = card.querySelector(selector);
          if (element && element.tagName === 'SPAN') {
            element.textContent = value;
          }
        };

        // Update input elements (only if not focused by user)
        const updateInput = (selector, value) => {
          const element = card.querySelector(selector);
          if (element && element.tagName === 'INPUT' && !element.matches(':focus')) {
            element.value = value;
          }
        };

        // Update real-time flight data (spans)
        updateSpan('.longitude', obj.longitude.toFixed(6) + 'Â°');
        updateSpan('.latitude', obj.latitude.toFixed(6) + 'Â°');
        updateSpan('.altitude', (obj.altitude * 3.28084).toFixed(0) + ' ft');
        updateSpan('.speed', obj.speed.toFixed(0) + ' kts');
        updateSpan('.heading', obj.heading.toFixed(0) + 'Â°');
        updateSpan('.pitch', obj.pitch.toFixed(1) + 'Â°');
        updateSpan('.roll', obj.roll.toFixed(1) + 'Â°');

        // Update editable fields (inputs) - only when not being edited
        const fuelInput = card.querySelector('input[onchange*="fuel"]');
        if (fuelInput && !fuelInput.matches(':focus')) {
          fuelInput.value = obj.fuel;
        }
        
        const timeInput = card.querySelector('input[onchange*="timeOnStation"]');
        if (timeInput && !timeInput.matches(':focus')) {
          timeInput.value = obj.timeOnStation;
        }
        
        const statusInput = card.querySelector('input[onchange*="status"]');
        if (statusInput && !statusInput.matches(':focus')) {
          statusInput.value = obj.status;
        }

        // NEVER update flight plan inputs to prevent editing issues
        // Flight plan waypoint inputs are managed separately and should not be refreshed
      });
    }

    // Real-time updates
    function updateObjects() {
      objects.forEach(obj => {
        obj.updateCalculatedFields();
      });
      updateObjectData(); // Only update data, not full HTML regeneration
    }

    // Update more frequently for real-time flight data
    // Check if any aircraft are flying and adjust update rate accordingly
    function getUpdateInterval() {
      const anyFlying = objects.some(obj => obj.isFlying);
      return anyFlying ? 200 : 1000; // 5 FPS when flying, 1 FPS when static
    }

    // Start with base interval
    let updateIntervalId = setInterval(updateObjects, 1000);

    // Dynamic update rate adjustment
    function adjustUpdateRate() {
      clearInterval(updateIntervalId);
      updateIntervalId = setInterval(updateObjects, getUpdateInterval());
    }

    // Check and adjust update rate every 2 seconds
    setInterval(adjustUpdateRate, 2000);

    // Aircraft types configuration
    const aircraftTypes = [
      {
        text: "F-35 Lightning II",
        platform: "Fighter",
        modelUrl: "assets/f-35b_lightning_ii.glb"
      },
      {
        text: "J-20 Mighty Dragon",
        platform: "Fighter", 
        modelUrl: "assets/chengdu_j-20_fighter_v2.glb"
      },
      {
        text: "Test Box",
        platform: "Test",
        modelUrl: "../SampleData/models/BoxInstanced/BoxInstanced.gltf"
      }
    ];

    // Setup dropdown
    const modelSelect = document.getElementById('modelSelect');
    aircraftTypes.forEach((aircraft, index) => {
      const option = document.createElement('option');
      option.value = index;
      option.text = aircraft.text;
      modelSelect.appendChild(option);
    });

    modelSelect.addEventListener('change', function() {
      const selectedIndex = parseInt(this.value);
      if (!isNaN(selectedIndex) && aircraftTypes[selectedIndex]) {
        const aircraft = aircraftTypes[selectedIndex];
        addObject(aircraft.text, aircraft.modelUrl, aircraft.platform);
        this.value = ''; // Reset selection
      }
    });

    // Flight planning global variables
    let currentPlanningObject = null;

    // Flight planning functions
    function toggleFlightPlanning(id) {
      const obj = objects.find(obj => obj.id === id);
      if (!obj) return;

      if (obj.isPlanning) {
        // Stop planning mode
        obj.isPlanning = false;
        currentPlanningObject = null;
        document.getElementById(`card_${id}`).classList.remove('planning-mode');
      } else {
        // Stop any other object's planning mode
        objects.forEach(o => {
          o.isPlanning = false;
          document.getElementById(`card_${o.id}`)?.classList.remove('planning-mode');
        });
        
        // Start planning mode
        obj.isPlanning = true;
        currentPlanningObject = obj;
        document.getElementById(`card_${id}`).classList.add('planning-mode');
      }
      
      updateObjectCards();
    }

    function startFlight(id) {
      const obj = objects.find(obj => obj.id === id);
      if (obj) {
        obj.startFlight();
        updateObjectCards();
      }
    }

    function stopFlight(id) {
      const obj = objects.find(obj => obj.id === id);
      if (obj) {
        obj.stopFlight();
        updateObjectCards();
      }
    }

    function clearFlightPlan(id) {
      const obj = objects.find(obj => obj.id === id);
      if (obj) {
        obj.clearFlightPlan();
        updateObjectCards();
      }
    }

    function removeWaypoint(objectId, waypointId) {
      const obj = objects.find(obj => obj.id === objectId);
      if (obj) {
        obj.removeWaypoint(waypointId);
        updateObjectCards();
      }
    }

    function updateFlightSpeed(id, newSpeed) {
      const obj = objects.find(obj => obj.id === id);
      if (obj) {
        obj.flightSpeed = parseFloat(newSpeed) || 250;
      }
    }

    function updateHeading(id, newHeading) {
      const obj = objects.find(obj => obj.id === id);
      if (obj) {
        let heading = parseFloat(newHeading) || 0;
        // Normalize heading to 0-360 degrees
        heading = ((heading % 360) + 360) % 360;
        obj.heading = heading;
        
        // Update entity orientation if not flying
        if (!obj.isFlying && obj.entity) {
          const position = Cesium.Cartesian3.fromDegrees(
            obj.longitude,
            obj.latitude,
            obj.altitude
          );
          
          // Convert from true north (0Â° = north) to Cesium system (0Â° = east)
          const cesiumHeading = obj.heading - 90;
          const headingRadians = Cesium.Math.toRadians(cesiumHeading);
          const pitchRadians = Cesium.Math.toRadians(obj.pitch);
          const rollRadians = Cesium.Math.toRadians(obj.roll);
          const hpr = new Cesium.HeadingPitchRoll(headingRadians, pitchRadians, rollRadians);
          const orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);
          
          obj.entity.orientation = orientation;
        }
      }
    }

    function updateWaypointAltitude(objectId, waypointId, newAltitudeFeet) {
      const obj = objects.find(obj => obj.id === objectId);
      if (obj) {
        const waypoint = obj.waypoints.find(wp => wp.id === waypointId);
        if (waypoint) {
          // Convert feet to meters
          waypoint.altitude = (parseFloat(newAltitudeFeet) || 0) / 3.28084;
          obj.updateFlightPath();
        }
      }
    }

    function updateWaypointSpeed(objectId, waypointId, newSpeed) {
      const obj = objects.find(obj => obj.id === objectId);
      if (obj) {
        const waypoint = obj.waypoints.find(wp => wp.id === waypointId);
        if (waypoint) {
          waypoint.speed = parseFloat(newSpeed) || 250; // Default to 250 knots
          obj.updateFlightPath();
        }
      }
    }

    function updateWaypointHeading(objectId, waypointId, newHeading) {
      const obj = objects.find(obj => obj.id === objectId);
      if (obj) {
        const waypoint = obj.waypoints.find(wp => wp.id === waypointId);
        if (waypoint) {
          if (newHeading === 'Auto' || newHeading === '' || isNaN(parseFloat(newHeading))) {
            waypoint.heading = undefined; // Auto-calculate
          } else {
            waypoint.heading = parseFloat(newHeading);
          }
          obj.updateFlightPath();
        }
      }
    }

    // Save and Load Flight Plan Functions
    function saveAllFlightPlans() {
      const objectsWithPlans = objects.filter(obj => obj.waypoints && obj.waypoints.length > 0);
      
      if (objectsWithPlans.length === 0) {
        alert('No flight plans to save!');
        return;
      }
      
      const allFlightPlans = {
        version: "1.0",
        timestamp: new Date().toISOString(),
        objects: objectsWithPlans.map(obj => ({
          callsign: obj.callsign,
          country: obj.country,
          platform: obj.platform,
          flightSpeed: obj.flightSpeed,
          flightPlan: {
            waypoints: obj.waypoints.map(wp => ({
              longitude: wp.longitude,
              latitude: wp.latitude,
              altitude: wp.altitude,
              speed: wp.speed,
              heading: wp.heading
            }))
          }
        }))
      };
      
      const jsonString = JSON.stringify(allFlightPlans, null, 2);
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = `all_flight_plans_${Date.now()}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      console.log(`Saved ${objectsWithPlans.length} flight plans`);
      alert(`Saved ${objectsWithPlans.length} flight plans`);
    }
    
    function loadFlightPlans() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      
      input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            const data = JSON.parse(e.target.result);
            
            // Handle both single flight plan and multiple flight plans
            let flightPlansToLoad = [];
            
            if (data.objects && Array.isArray(data.objects)) {
              // Multiple flight plans format
              flightPlansToLoad = data.objects;
            } else if (data.flightPlan && data.flightPlan.waypoints) {
              // Single flight plan format (backward compatibility)
              flightPlansToLoad = [data];
            } else {
              alert('Invalid flight plan format!');
              return;
            }
            
            let loadedCount = 0;
            
            flightPlansToLoad.forEach(planData => {
              // Try to find existing object by callsign first
              let targetObj = objects.find(obj => obj.callsign === planData.callsign);
              
              if (!targetObj && objects.length > 0) {
                // If no matching callsign, ask user to select an object
                const objectList = objects.map((obj, index) => `${index}: ${obj.callsign} (${obj.type})`).join('\n');
                const selection = prompt(
                  `Load flight plan for "${planData.callsign}" onto which object?\n\n${objectList}\n\nEnter object number (or cancel):`,
                  '0'
                );
                
                if (selection !== null && !isNaN(selection)) {
                  const objIndex = parseInt(selection);
                  if (objIndex >= 0 && objIndex < objects.length) {
                    targetObj = objects[objIndex];
                  }
                }
              }
              
              if (targetObj) {
                // Clear existing waypoints and flight path
                targetObj.clearFlightPlan();
                
                // Load flight speed if provided
                if (planData.flightSpeed) {
                  targetObj.flightSpeed = planData.flightSpeed;
                }
                
                // Load waypoints
                planData.flightPlan.waypoints.forEach(wp => {
                  targetObj.addWaypoint(wp.longitude, wp.latitude, wp.altitude);
                  // Update last waypoint with speed and heading if provided
                  const lastWP = targetObj.waypoints[targetObj.waypoints.length - 1];
                  if (wp.speed) lastWP.speed = wp.speed;
                  if (wp.heading !== undefined) lastWP.heading = wp.heading;
                });
                
                // Update flight path
                if (targetObj.waypoints.length > 1) {
                  targetObj.updateFlightPath();
                }
                
                loadedCount++;
                console.log(`Loaded flight plan for ${targetObj.callsign}: ${targetObj.waypoints.length} waypoints`);
              }
            });
            
            updateObjectCards();
            alert(`Loaded ${loadedCount} flight plans`);
            
          } catch (error) {
            alert('Error loading flight plans: ' + error.message);
            console.error('Flight plans load error:', error);
          }
        };
        
        reader.readAsText(file);
      };
      
      input.click();
    }
    
    // Individual flight plan functions (kept for backward compatibility)
    function saveFlightPlan(id) {
      const obj = objects.find(obj => obj.id === id);
      if (!obj || obj.waypoints.length === 0) {
        alert('No flight plan to save!');
        return;
      }
      
      const flightPlanData = {
        version: "1.0",
        callsign: obj.callsign,
        country: obj.country,
        platform: obj.platform,
        flightSpeed: obj.flightSpeed,
        flightPlan: {
          waypoints: obj.waypoints.map(wp => ({
            longitude: wp.longitude,
            latitude: wp.latitude,
            altitude: wp.altitude,
            speed: wp.speed,
            heading: wp.heading
          }))
        }
      };
      
      const jsonString = JSON.stringify(flightPlanData, null, 2);
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = `flight_plan_${obj.callsign}_${Date.now()}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      console.log(`Saved flight plan for ${obj.callsign}`);
    }
    
    function loadFlightPlan(id) {
      const obj = objects.find(obj => obj.id === id);
      if (!obj) return;
      
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      
      input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            const flightPlanData = JSON.parse(e.target.result);
            
            if (!flightPlanData.flightPlan || !flightPlanData.flightPlan.waypoints) {
              alert('Invalid flight plan format!');
              return;
            }
            
            // Clear existing waypoints and flight path
            obj.clearFlightPlan();
            
            // Load flight speed if provided
            if (flightPlanData.flightSpeed) {
              obj.flightSpeed = flightPlanData.flightSpeed;
            }
            
            // Load waypoints
            flightPlanData.flightPlan.waypoints.forEach(wp => {
              obj.addWaypoint(wp.longitude, wp.latitude, wp.altitude);
              // Update last waypoint with speed and heading if provided
              const lastWP = obj.waypoints[obj.waypoints.length - 1];
              if (wp.speed) lastWP.speed = wp.speed;
              if (wp.heading !== undefined) lastWP.heading = wp.heading;
            });
            
            // Update flight path
            if (obj.waypoints.length > 1) {
              obj.updateFlightPath();
            }
            
            updateObjectCards();
            console.log(`Loaded flight plan for ${obj.callsign}: ${obj.waypoints.length} waypoints`);
            
          } catch (error) {
            alert('Error loading flight plan: ' + error.message);
            console.error('Flight plan load error:', error);
          }
        };
        
        reader.readAsText(file);
      };
      
      input.click();
    }

    // DEBUG FUNCTIONS for testing orientation and position changes
    function testBankAngle(id) {
      const obj = objects.find(obj => obj.id === id);
      if (obj && obj.entity) {
        console.log('Testing bank angle for object', id);
        
        // Update object data
        obj.roll = 30;
        
        // Get current position
        const position = Cesium.Cartesian3.fromDegrees(
          obj.longitude,
          obj.latitude,
          obj.altitude
        );
        
        // Create new orientation with 30 degree bank
        const cesiumHeading = obj.heading - 90; // Convert to Cesium coordinates
        const headingRadians = Cesium.Math.toRadians(cesiumHeading);
        const pitchRadians = Cesium.Math.toRadians(obj.pitch);
        const rollRadians = Cesium.Math.toRadians(30); // 30 degree bank
        
        const hpr = new Cesium.HeadingPitchRoll(headingRadians, pitchRadians, rollRadians);
        const orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);
        
        // Apply directly to entity
        obj.entity.orientation = orientation;
        
        console.log('Applied 30Â° bank angle to entity');
        updateObjectCards();
      }
    }

    function testAltitude(id) {
      const obj = objects.find(obj => obj.id === id);
      if (obj && obj.entity) {
        console.log('Testing altitude change for object', id);
        
        // Update object data
        const newAltitudeFeet = 30000;
        const newAltitudeMeters = newAltitudeFeet / 3.28084;
        obj.altitude = newAltitudeMeters;
        
        // Create new position at 30,000 feet
        const position = Cesium.Cartesian3.fromDegrees(
          obj.longitude,
          obj.latitude,
          newAltitudeMeters
        );
        
        // Apply directly to entity
        obj.entity.position = position;
        
        console.log('Changed altitude to 30,000 feet');
        updateObjectCards();
      }
    }

    function testReset(id) {
      const obj = objects.find(obj => obj.id === id);
      if (obj && obj.entity) {
        console.log('Resetting object to original state', id);
        
        // Reset object data
        obj.roll = 0;
        obj.pitch = 0;
        
        // Reset to original position and orientation
        const position = Cesium.Cartesian3.fromDegrees(
          obj.longitude,
          obj.latitude,
          obj.altitude
        );
        
        const cesiumHeading = obj.heading - 90;
        const headingRadians = Cesium.Math.toRadians(cesiumHeading);
        const pitchRadians = Cesium.Math.toRadians(0);
        const rollRadians = Cesium.Math.toRadians(0);
        
        const hpr = new Cesium.HeadingPitchRoll(headingRadians, pitchRadians, rollRadians);
        const orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);
        
        obj.entity.position = position;
        obj.entity.orientation = orientation;
        
        console.log('Reset object to original state');
        updateObjectCards();
      }
    }

    // Click handler for waypoint creation
    viewer.cesiumWidget.canvas.addEventListener('click', function(e) {
      if (!currentPlanningObject) return;

      const pick = viewer.camera.getPickRay(new Cesium.Cartesian2(e.clientX, e.clientY));
      const pickedPosition = viewer.scene.globe.pick(pick, viewer.scene);
      
      if (pickedPosition) {
        const cartographic = Cesium.Cartographic.fromCartesian(pickedPosition);
        const longitude = Cesium.Math.toDegrees(cartographic.longitude);
        const latitude = Cesium.Math.toDegrees(cartographic.latitude);
        const altitude = 0; // Default altitude set to 0

        currentPlanningObject.addWaypoint(longitude, latitude, altitude);
        updateObjectCards();
      }
    }, false);

    // Make functions global for onclick handlers
    window.updateObjectField = updateObjectField;
    window.focusObject = focusObject;
    window.trackObject = trackObject;
    window.duplicateObject = duplicateObject;
    window.removeObject = removeObject;
    window.toggleFlightPlanning = toggleFlightPlanning;
    window.startFlight = startFlight;
    window.stopFlight = stopFlight;
    window.clearFlightPlan = clearFlightPlan;
    window.removeWaypoint = removeWaypoint;
    window.updateFlightSpeed = updateFlightSpeed;
    window.updateHeading = updateHeading;
    window.updateWaypointAltitude = updateWaypointAltitude;
    window.updateWaypointSpeed = updateWaypointSpeed;
    window.updateWaypointHeading = updateWaypointHeading;
    window.saveAllFlightPlans = saveAllFlightPlans;
    window.loadFlightPlans = loadFlightPlans;
    window.saveFlightPlan = saveFlightPlan;
    window.loadFlightPlan = loadFlightPlan;
    window.testBankAngle = testBankAngle;
    window.testAltitude = testAltitude;
    window.testReset = testReset;

  </script>

 </div>

</body>

</html>

