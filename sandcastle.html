<!DOCTYPE html>

<html lang="en">

<head>

  <meta charset="utf-8">

  <!-- Include the CesiumJS JavaScript and CSS files -->

  <script src="https://cesium.com/downloads/cesiumjs/releases/1.133/Build/Cesium/Cesium.js"></script>

  <link href="https://cesium.com/downloads/cesiumjs/releases/1.133/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    #cesiumContainer {
      width: calc(100% - 350px);
      height: 100vh;
      float: left;
    }

    .cesium-viewer-toolbar {
      position: absolute;
      top: 10px;
      left: 40px; /* Move right to make room for toggle */
      z-index: 100;
      transition: transform 0.3s ease;
    }

    .cesium-viewer-toolbar.hidden {
      transform: translateX(-100%);
    }

    #flight-management-container {
      position: absolute;
      top: 10px;
      right: 370px; /* 350px panel width + 20px gap */
      z-index: 100;
      display: flex;
      align-items: flex-start;
      gap: 5px;
      transition: transform 0.3s ease;
    }

    #flight-management-container.hidden {
      display: none;
    }

    #add-object-toolbar {
      background: rgba(42, 42, 42, 0.9);
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      transition: transform 0.3s ease;
    }

    #add-object-toolbar.hidden {
      transform: translateX(-100%);
    }

    #toolbar-toggle {
      position: absolute;
      top: 10px; /* Aligned with flight management container */
      right: 340px; /* Just to the left of flight management container */
      z-index: 101; /* Above other elements */
      background: rgba(42, 42, 42, 0.9);
      border: 1px solid #666;
      color: white;
      padding: 5px 8px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
    }

    #toolbar-toggle:hover {
      background: rgba(60, 60, 60, 0.9);
    }

    #cesium-toolbar-toggle {
      position: absolute;
      top: 10px; /* Aligned with cesium toolbar */
      left: 10px; /* At the left edge, before cesium toolbar */
      z-index: 101; /* Above cesium toolbar */
      background: rgba(42, 42, 42, 0.9);
      border: 1px solid #666;
      color: white;
      padding: 5px 8px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
    }

    #cesium-toolbar-toggle:hover {
      background: rgba(60, 60, 60, 0.9);
    }

    #load-flight-btn {
      background: #4a9eff;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 14px;
      margin-bottom: 10px;
      width: 100%;
    }

    #load-flight-btn:hover {
      background: #3a8eef;
    }

    #load-flight-input {
      display: none;
    }
    
    #modelSelect {
      background: #444;
      color: white;
      border: 1px solid #666;
      border-radius: 3px;
      padding: 8px 12px;
      font-family: inherit;
      font-size: 14px;
      cursor: pointer;
    }
    
    #modelSelect option {
      background: #444;
      color: white;
    }

    #objects-panel {
      width: 350px;
      height: 100vh;
      float: right;
      background: #2a2a2a;
      color: white;
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
      border-left: 1px solid #444;
    }

    #objects-panel h3 {
      margin-top: 0;
      margin-bottom: 15px;
      color: #fff;
      font-size: 18px;
    }

    .object-card {
      background: #363636;
      border: 1px solid #555;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }

    .object-card h4 {
      margin: 0 0 10px 0;
      color: #4a9eff;
      font-size: 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .object-info {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      font-size: 12px;
    }

    .object-info div {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
      border-bottom: 1px solid #444;
    }

    .object-info label {
      color: #aaa;
      font-weight: 500;
    }

    .object-info span {
      color: #fff;
      font-family: 'Courier New', monospace;
    }

    .editable {
      background: transparent;
      border: none;
      color: #fff;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      text-align: right;
      width: 80px;
    }

    .editable:focus {
      background: #444;
      outline: 1px solid #4a9eff;
    }

    .object-controls {
      display: flex;
      gap: 8px;
      margin-top: 10px;
    }

    .btn {
      background: #4a9eff;
      color: white;
      border: none;
      padding: 4px 8px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
    }

    .btn:hover {
      background: #3a8eef;
    }

    .btn.danger {
      background: #ff4757;
    }

    .btn.danger:hover {
      background: #ff3a4f;
    }

    .flight-planning {
      margin-top: 15px;
      padding-top: 10px;
      border-top: 1px solid #555;
    }

    .flight-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
      align-items: center;
    }

    .flight-status {
      font-size: 11px;
      color: #aaa;
      margin-left: 10px;
    }

    .waypoint-list {
      max-height: 120px;
      overflow-y: auto;
      background: #2a2a2a;
      border: 1px solid #555;
      border-radius: 3px;
      margin-top: 8px;
    }

    .waypoint-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 8px;
      border-bottom: 1px solid #444;
      font-size: 11px;
    }

    .waypoint-item:last-child {
      border-bottom: none;
    }

    .waypoint-coords {
      color: #4a9eff;
      font-family: 'Courier New', monospace;
    }

    .waypoint-controls {
      display: flex;
      gap: 4px;
    }

    .btn-small {
      background: #666;
      color: white;
      border: none;
      padding: 2px 6px;
      border-radius: 2px;
      cursor: pointer;
      font-size: 10px;
    }

    .btn-small:hover {
      background: #777;
    }

    .planning-mode {
      background: #2d4a2d !important;
      border-color: #4a9a4a !important;
    }

    .planning-mode h4 {
      color: #4a9a4a !important;
    }

    #global-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #555;
    }

    .object-card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      margin-bottom: 10px;
    }

    .object-card-header h4 {
      margin: 0;
      flex: 1;
    }

    .caret {
      width: 0;
      height: 0;
      border-left: 6px solid #aaa;
      border-top: 6px solid transparent;
      border-bottom: 6px solid transparent;
      transition: transform 0.2s ease;
      margin-left: 10px;
      cursor: pointer;
    }

    .caret.collapsed {
      transform: rotate(-90deg);
    }

    .object-card-content {
      transition: max-height 0.3s ease, opacity 0.3s ease;
      overflow: hidden;
      max-height: 2000px;
      opacity: 1;
    }

    .object-card-content.collapsed {
      max-height: 0;
      opacity: 0;
    }

    .object-card.collapsed {
      padding-bottom: 15px;
    }
  </style>

</head>

<body>

  <div id="cesiumContainer"></div>
  
  <div class="cesium-viewer-toolbar">
    <!-- Cesium's built-in toolbar content will appear here -->
  </div>
  
  <div id="cesium-toolbar-toggle" onclick="toggleCesiumToolbar()">◀</div>
  
  <div id="flight-management-container">
    <div id="add-object-toolbar">
      <button id="load-flight-btn" onclick="triggerFileLoad()">Load Flight</button>
      <input type="file" id="load-flight-input" accept=".json" onchange="loadFlightData(event)">
      <select id="modelSelect">
        <option value="">Add New Object</option>
      </select>
    </div>
  </div>
  
  <div id="toolbar-toggle" onclick="toggleToolbar()">◀</div>

  <div id="objects-panel">
    <h3>Active Objects</h3>
    <div id="global-controls">
      <button class="btn" onclick="startAllFlights()">Start All Flights</button>
      <button class="btn danger" onclick="stopAllFlights()">Stop All Flights</button>
      <button class="btn" onclick="saveAllObjects()">Save All</button>
    </div>
    <div id="object-cards-container"></div>
  </div>

  <script type="module">
    // Multi-Object Tracking System
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJmNGU2YTQwYi05ZGFkLTQ5ZWYtOTJlNC0zY2EwNmUzZDA4MGYiLCJpZCI6MzM4ODAyLCJpYXQiOjE3NTcwOTUxMzd9.gDyQcH0fKKNQxGIQjzSyjbQt1tjWDERbZt4eUna9Xbc';

    // Initialize Cesium Viewer
    const viewer = new Cesium.Viewer("cesiumContainer", {
      shadows: true,
      shouldAnimate: true,
    });

    // Fly to San Francisco startup view
    viewer.camera.flyTo({
      destination: Cesium.Cartesian3.fromDegrees(-122.4175, 37.655, 400),
      orientation: {
        heading: Cesium.Math.toRadians(0.0),
        pitch: Cesium.Math.toRadians(-15.0),
      }
    });

    // Global object management
    let objects = [];
    let nextObjectId = 1;

    // Object styling configuration
    const ObjectStyleConfig = {
      countries: {
        "USA": {
          fontColor: "#0000FF",
          flightPathColor: "#0000FF"
        },
        "China": {
          fontColor: "#FF0000", 
          flightPathColor: "#FF0000"
        }
      },
      aircraftMapping: {
        "J-20 Mighty Dragon": "China",
        "F-35 Lightning II": "USA"
      },
      default: {
        fontColor: "#4a9eff",
        flightPathColor: "#00FFFF"
      }
    };

    // Function to determine country based on aircraft type
    function getCountryFromAircraftType(aircraftType) {
      for (const [aircraft, country] of Object.entries(ObjectStyleConfig.aircraftMapping)) {
        if (aircraftType.includes(aircraft)) {
          return country;
        }
      }
      return "USA"; // Default fallback
    }

    // Function to get styling for a country
    function getCountryStyle(country) {
      return ObjectStyleConfig.countries[country] || ObjectStyleConfig.default;
    }

    // JSON Schema for object and flight plan data
    const ObjectDataSchema = {
      type: "object",
      properties: {
        version: { type: "string", description: "Schema version" },
        timestamp: { type: "string", description: "Save timestamp" },
        objects: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "number" },
              type: { type: "string" },
              modelUrl: { type: "string" },
              platform: { type: "string" },
              position: {
                type: "object",
                properties: {
                  longitude: { type: "number" },
                  latitude: { type: "number" },
                  altitude: { type: "number" }
                },
                required: ["longitude", "latitude", "altitude"]
              },
              orientation: {
                type: "object",
                properties: {
                  heading: { type: "number" },
                  pitch: { type: "number" },
                  roll: { type: "number" }
                },
                required: ["heading", "pitch", "roll"]
              },
              metadata: {
                type: "object",
                properties: {
                  callsign: { type: "string" },
                  country: { type: "string" },
                  fuel: { type: "string" },
                  timeOnStation: { type: "string" },
                  loadout: { type: "string" },
                  status: { type: "string" },
                  mission: { type: "string" },
                  task: { type: "string" }
                }
              },
              flightPlan: {
                type: "object",
                properties: {
                  waypoints: {
                    type: "array",
                    items: {
                      type: "object",
                      properties: {
                        longitude: { type: "number" },
                        latitude: { type: "number" },
                        altitude: { type: "number" },
                        speed: { type: "number" },
                        heading: { type: "number" }
                      },
                      required: ["longitude", "latitude", "altitude"]
                    }
                  },
                  flightSpeed: { type: "number" }
                }
              }
            },
            required: ["id", "type", "modelUrl", "platform", "position", "orientation", "metadata"]
          }
        }
      },
      required: ["version", "timestamp", "objects"]
    };

    // Platform-specific turn rates (degrees per second)
    const PLATFORM_TURN_RATES = {
      'Fighter': 20,
      'Bomber': 8,
      'Transport': 5,
      'UAV': 15
    };

    // Object data structure
    class TrackedObject {
      constructor(type, modelUrl, platform, initialHeading = null) {
        this.id = nextObjectId++;
        this.type = type;
        this.modelUrl = modelUrl;
        this.platform = platform;
        this.turnRate = PLATFORM_TURN_RATES[platform] || 10; // degrees per second
        
        // Calculated from Cesium entity
        this.longitude = -122.4175 + (Math.random() - 0.5) * 0.1;
        this.latitude = 37.655 + (Math.random() - 0.5) * 0.1;
        this.altitude = 10000 + Math.random() * 20000;
        this.speed = 0;
        this.heading = initialHeading !== null ? initialHeading : Math.random() * 360; // Random heading 0-360 degrees
        this.pitch = 0;
        this.roll = 0;
        
        // Editable metadata - determine country from aircraft type
        this.country = getCountryFromAircraftType(type);
        this.callsign = `${type}${String(this.id).padStart(2, '0')}`;
        this.fuel = '75%';
        this.timeOnStation = '2h 15m';
        this.loadout = 'Standard';
        this.status = 'Active';
        this.mission = 'CAP';
        this.task = 'Patrol';
        this.flightPlan = 'None';
        
        // Flight planning
        this.waypoints = [];
        this.flightPath = null;
        this.isPlanning = false;
        this.isFlying = false;
        this.flightProgress = 0;
        this.flightSpeed = 250; // knots
        this.flightStartTime = null;
        
        this.entity = null;
        this.createEntity();
      }

      createEntity() {
        const position = Cesium.Cartesian3.fromDegrees(
          this.longitude,
          this.latitude,
          this.altitude
        );

        // Convert from true north (0° = north) to Cesium system (0° = east)
        // Subtract 90 degrees to convert from geographic heading to Cesium heading
        const cesiumHeading = this.heading - 90;
        const headingRadians = Cesium.Math.toRadians(cesiumHeading);
        const pitchRadians = Cesium.Math.toRadians(this.pitch);
        const rollRadians = Cesium.Math.toRadians(this.roll);
        const hpr = new Cesium.HeadingPitchRoll(headingRadians, pitchRadians, rollRadians);
        const orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);

        this.entity = viewer.entities.add({
          id: `object_${this.id}`,
          name: this.callsign,
          position: position,
          orientation: orientation,
          model: {
            uri: this.modelUrl,
            minimumPixelSize: 128,
            maximumScale: 20000,
          },
        });
      }

      updateCalculatedFields() {
        if (!this.entity) return;
        
        const currentTime = viewer.clock.currentTime;
        const position = this.entity.position.getValue(currentTime);
        let previousPosition = null;
        
        // Get previous position for speed calculation
        const previousTime = Cesium.JulianDate.addSeconds(currentTime, -1, new Cesium.JulianDate());
        try {
          previousPosition = this.entity.position.getValue(previousTime);
        } catch (e) {
          // Handle case where previous time is outside the sample range
          previousPosition = null;
        }
        
        if (position) {
          const cartographic = Cesium.Cartographic.fromCartesian(position);
          this.longitude = Cesium.Math.toDegrees(cartographic.longitude);
          this.latitude = Cesium.Math.toDegrees(cartographic.latitude);
          this.altitude = cartographic.height;
          
          // Calculate speed if we have a previous position
          if (previousPosition && this.isFlying) {
            const distance = Cesium.Cartesian3.distance(previousPosition, position);
            this.speed = distance * 1.94384; // Convert m/s to knots
          } else if (!this.isFlying) {
            this.speed = 0;
          }
        }

        // Extract current orientation from the dynamic flight animation
        if (this.isFlying && this.entity.orientation) {
          const orientation = this.entity.orientation.getValue(currentTime);
          if (orientation && position) {
            try {
              // Create the local reference frame at the aircraft's position
              const transform = Cesium.Transforms.eastNorthUpToFixedFrame(position);
              const transformMatrix = Cesium.Matrix4.getMatrix3(transform, new Cesium.Matrix3());
              
              // Convert quaternion to rotation matrix
              const orientationMatrix = Cesium.Matrix3.fromQuaternion(orientation);
              
              // Transform to local coordinate system
              const localMatrix = Cesium.Matrix3.multiply(
                Cesium.Matrix3.transpose(transformMatrix, new Cesium.Matrix3()),
                orientationMatrix,
                new Cesium.Matrix3()
              );
              
              // Extract Euler angles from the local rotation matrix
              // Using the ZYX rotation order (yaw-pitch-roll)
              const m = localMatrix;
              
              // Calculate pitch (rotation about Y axis)
              const pitch = Math.asin(-m[6]); // -sin(pitch) = -m[2][0]
              
              // Calculate heading (rotation about Z axis)  
              let heading = Math.atan2(m[3], m[0]); // atan2(sin(yaw), cos(yaw))
              
              // Calculate roll (rotation about X axis)
              const roll = Math.atan2(m[7], m[8]); // atan2(sin(roll), cos(roll))
              
              // Convert to degrees and adjust coordinate system
              this.heading = (Cesium.Math.toDegrees(heading) + 90 + 360) % 360;
              this.pitch = Cesium.Math.toDegrees(pitch);
              this.roll = Cesium.Math.toDegrees(roll);
              
            } catch (e) {
              console.error('Error extracting orientation:', e);
              // Keep existing values if calculation fails
            }
          }
        }
        
        // Update flight-specific data
        if (this.isFlying) {
          this.updateFlightData();
        }
      }
      
      updateFlightData() {
        if (!this.flightStartTime) return;
        
        const elapsedTime = (Date.now() - this.flightStartTime) / 1000; // seconds
        const elapsedMinutes = Math.floor(elapsedTime / 60);
        const elapsedSeconds = Math.floor(elapsedTime % 60);
        
        // Update time on station (flight time)
        this.timeOnStation = `${elapsedMinutes}m ${elapsedSeconds}s`;
        
        // Simple fuel consumption model (1% per minute of flight)
        if (this.originalFuel === undefined) {
          this.originalFuel = parseFloat(this.fuel.replace('%', '')) || 75;
        }
        
        const fuelConsumptionRate = 1.0; // 1% per minute
        const consumedFuel = (elapsedMinutes * fuelConsumptionRate);
        const remainingFuel = Math.max(0, this.originalFuel - consumedFuel);
        this.fuel = `${remainingFuel.toFixed(0)}%`;
        
        // Update status based on flight progress
        if (remainingFuel <= 10) {
          this.status = 'Low Fuel';
        } else if (remainingFuel <= 25) {
          this.status = 'Fuel Warning';
        } else {
          this.status = 'Flying';
        }
      }

      addWaypoint(longitude, latitude, altitude) {
        this.waypoints.push({
          longitude: longitude,
          latitude: latitude,
          altitude: altitude || 0, // Default to 0 altitude
          speed: this.flightSpeed || 250, // Default speed in knots
          heading: undefined, // Auto-calculate heading
          id: Date.now()
        });
        this.updateFlightPath();
        // Force card regeneration when waypoints change
        setTimeout(() => updateObjectCards(), 100);
      }

      removeWaypoint(waypointId) {
        this.waypoints = this.waypoints.filter(wp => wp.id !== waypointId);
        this.updateFlightPath();
        // Force card regeneration when waypoints change
        setTimeout(() => updateObjectCards(), 100);
      }

      updateFlightPath() {
        if (this.flightPath) {
          viewer.entities.remove(this.flightPath);
          this.flightPath = null;
        }

        if (this.waypoints.length > 1) {
          const positions = this.waypoints.map(wp => 
            Cesium.Cartesian3.fromDegrees(wp.longitude, wp.latitude, wp.altitude)
          );

          // Get country-specific color for flight path
          const countryStyle = getCountryStyle(this.country);
          const flightPathColor = Cesium.Color.fromCssColorString(countryStyle.flightPathColor);

          this.flightPath = viewer.entities.add({
            id: `flightPath_${this.id}`,
            name: `${this.callsign} Flight Path`,
            polyline: {
              positions: positions,
              width: 3,
              material: flightPathColor,
              clampToGround: false,
              followSurface: false,
            }
          });
        }
      }

      startFlight() {
        if (this.waypoints.length < 2) return;
        
        this.isFlying = true;
        this.flightProgress = 0;
        this.flightStartTime = Date.now();
        
        // Store original fuel level for consumption tracking
        if (this.originalFuel === undefined) {
          this.originalFuel = parseFloat(this.fuel.replace('%', '')) || 75;
        }

        // Create flight animation with per-waypoint speeds
        const positions = this.waypoints.map(wp => 
          Cesium.Cartesian3.fromDegrees(wp.longitude, wp.latitude, wp.altitude)
        );

        // Calculate time for each leg based on waypoint speeds
        const flightData = [];
        let cumulativeTime = this.flightStartTime;
        
        for (let i = 0; i < this.waypoints.length; i++) {
          const waypoint = this.waypoints[i];
          
          if (i > 0) {
            // Calculate distance to this waypoint from previous
            const prevPos = positions[i - 1];
            const currentPos = positions[i];
            const segmentDistance = Cesium.Cartesian3.distance(prevPos, currentPos) / 1000; // km
            
            // Use waypoint's speed (or default speed) to calculate time
            const waypointSpeed = waypoint.speed || this.flightSpeed || 250; // knots
            const speedKmh = waypointSpeed * 1.852; // Convert knots to km/h
            const segmentTimeHours = segmentDistance / speedKmh;
            const segmentTimeMs = segmentTimeHours * 3600 * 1000; // Convert to milliseconds
            
            cumulativeTime += segmentTimeMs;
          }
          
          // Use waypoint heading if specified, otherwise calculate
          let heading = 0;
          let pitch = 0;
          let roll = 0; // Banking angle
          
          if (waypoint.heading !== undefined) {
            // Use specified heading
            heading = Cesium.Math.toRadians(waypoint.heading);
          } else {
            // Calculate heading towards next waypoint
            if (i < this.waypoints.length - 1) {
              const currentPos = positions[i];
              const nextPos = positions[i + 1];
              
              // Calculate bearing between points (geographic bearing)
              const currentCart = Cesium.Cartographic.fromCartesian(currentPos);
              const nextCart = Cesium.Cartographic.fromCartesian(nextPos);
              
              const deltaLon = nextCart.longitude - currentCart.longitude;
              const lat1 = currentCart.latitude;
              const lat2 = nextCart.latitude;
              
              const y = Math.sin(deltaLon) * Math.cos(lat2);
              const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLon);
              
              // Geographic bearing (0 = north)
              heading = Math.atan2(y, x);
            } else {
              // Last waypoint - maintain previous heading
              if (flightData.length > 0) {
                heading = flightData[flightData.length - 1].heading;
              } else {
                heading = Cesium.Math.toRadians(this.heading);
              }
            }
          }
          
          // Calculate pitch based on altitude change
          if (i < this.waypoints.length - 1) {
            const currentPos = positions[i];
            const nextPos = positions[i + 1];
            const currentCart = Cesium.Cartographic.fromCartesian(currentPos);
            const nextCart = Cesium.Cartographic.fromCartesian(nextPos);
            
            const currentAlt = currentCart.height;
            const nextAlt = nextCart.height;
            const distance = Cesium.Cartesian3.distance(currentPos, nextPos);
            const altitudeChange = nextAlt - currentAlt;
            pitch = Math.atan2(altitudeChange, distance);
          } else {
            pitch = 0;
          }
          
          flightData.push({
            time: cumulativeTime,
            position: positions[i],
            heading: heading,
            pitch: pitch,
            roll: roll
          });
        }

        // Calculate lead-turn points for each waypoint using actual waypoint positions (MUST be before enhanced flight path)
        const leadTurnData = [];
        for (let i = 1; i < this.waypoints.length - 1; i++) {
          const inboundWP = this.waypoints[i - 1];
          const turnWP = this.waypoints[i];
          const outboundWP = this.waypoints[i + 1];
          
          // Calculate actual course headings from waypoint positions
          const inboundCart = Cesium.Cartographic.fromDegrees(inboundWP.longitude, inboundWP.latitude);
          const turnCart = Cesium.Cartographic.fromDegrees(turnWP.longitude, turnWP.latitude);
          const outboundCart = Cesium.Cartographic.fromDegrees(outboundWP.longitude, outboundWP.latitude);
          
          // Inbound course (approaching turnWP)
          const inboundDeltaLon = turnCart.longitude - inboundCart.longitude;
          const inboundY = Math.sin(inboundDeltaLon) * Math.cos(turnCart.latitude);
          const inboundX = Math.cos(inboundCart.latitude) * Math.sin(turnCart.latitude) - 
                          Math.sin(inboundCart.latitude) * Math.cos(turnCart.latitude) * Math.cos(inboundDeltaLon);
          const inboundCourse = Math.atan2(inboundY, inboundX);
          
          // Outbound course (departing turnWP)
          const outboundDeltaLon = outboundCart.longitude - turnCart.longitude;
          const outboundY = Math.sin(outboundDeltaLon) * Math.cos(outboundCart.latitude);
          const outboundX = Math.cos(turnCart.latitude) * Math.sin(outboundCart.latitude) - 
                           Math.sin(turnCart.latitude) * Math.cos(outboundCart.latitude) * Math.cos(outboundDeltaLon);
          const outboundCourse = Math.atan2(outboundY, outboundX);
          
          // Calculate heading change needed
          let headingChange = outboundCourse - inboundCourse;
          while (headingChange > Math.PI) headingChange -= 2 * Math.PI;
          while (headingChange < -Math.PI) headingChange += 2 * Math.PI;
          
          if (Math.abs(headingChange) > 0.01) {
            const headingChangeDegrees = Math.abs(Cesium.Math.toDegrees(headingChange));
            
            // For turns ≥90°, split into two steps to prevent abrupt heading changes
            if (headingChangeDegrees >= 90) {
              // Step 1: Turn 89° toward target
              const firstTurnDegrees = 89;
              const firstTurnRadians = Math.sign(headingChange) * Cesium.Math.toRadians(firstTurnDegrees);
              const firstTurnDuration = firstTurnDegrees / this.turnRate; // seconds
              
              // Step 2: Complete remaining turn
              const remainingTurnDegrees = headingChangeDegrees - firstTurnDegrees;
              const remainingTurnRadians = Math.sign(headingChange) * Cesium.Math.toRadians(remainingTurnDegrees);
              const remainingTurnDuration = remainingTurnDegrees / this.turnRate; // seconds
              
              const totalTurnDuration = firstTurnDuration + remainingTurnDuration;
              
              // Calculate intermediate heading after first 89° turn
              const intermediateHeading = inboundCourse + firstTurnRadians;
              
              // Calculate lead time for the entire two-step turn
              const leadTime = totalTurnDuration * 0.5;
              const turnWPTime = flightData[i].time;
              const leadTurnStartTime = turnWPTime - (leadTime * 1000);
              
              // First turn phase
              leadTurnData.push({
                waypointIndex: i,
                leadTurnStartTime: leadTurnStartTime,
                turnDuration: firstTurnDuration * 1000, // Convert to milliseconds
                headingChange: firstTurnRadians,
                inboundCourse: inboundCourse,
                outboundCourse: intermediateHeading,
                turnWaypoint: turnWP,
                nextWaypoint: outboundWP,
                isFirstPhase: true,
                totalTurnPhases: 2
              });
              
              // Second turn phase (starts immediately after first phase)
              leadTurnData.push({
                waypointIndex: i,
                leadTurnStartTime: leadTurnStartTime + (firstTurnDuration * 1000),
                turnDuration: remainingTurnDuration * 1000, // Convert to milliseconds
                headingChange: remainingTurnRadians,
                inboundCourse: intermediateHeading,
                outboundCourse: outboundCourse,
                turnWaypoint: turnWP,
                nextWaypoint: outboundWP,
                isSecondPhase: true,
                totalTurnPhases: 2
              });
              
            } else {
              // Single-step turn for turns <90°
              const turnDuration = headingChangeDegrees / this.turnRate; // seconds
              
              // Calculate lead time needed to complete turn by waypoint
              const leadTime = turnDuration * 0.5; // Start turn halfway before waypoint arrival
              const turnWPTime = flightData[i].time;
              const leadTurnStartTime = turnWPTime - (leadTime * 1000); // Convert to milliseconds
              
              leadTurnData.push({
                waypointIndex: i,
                leadTurnStartTime: leadTurnStartTime,
                turnDuration: turnDuration * 1000, // Convert to milliseconds
                headingChange: headingChange,
                inboundCourse: inboundCourse,
                outboundCourse: outboundCourse,
                turnWaypoint: turnWP,
                nextWaypoint: outboundWP,
                totalTurnPhases: 1
              });
            }
          }
        }

        // Create enhanced flight path with realistic turn geometry
        const enhancedFlightData = [];
        
        for (let i = 0; i < flightData.length - 1; i++) {
          const currentWP = flightData[i];
          const nextWP = flightData[i + 1];
          
          enhancedFlightData.push(currentWP);
          
          // Add intermediate points for realistic turn geometry
          const segmentTime = nextWP.time - currentWP.time;
          const numIntermediate = Math.max(1, Math.floor(segmentTime / (5 * 1000))); // One point every 5 seconds
          
          for (let j = 1; j < numIntermediate; j++) {
            const factor = j / numIntermediate;
            const intermediateTime = currentWP.time + (segmentTime * factor);
            
            // Check if this time falls within any turn
            let inTurn = false;
            let turnData = null;
            for (const turn of leadTurnData) {
              if (intermediateTime >= turn.leadTurnStartTime && 
                  intermediateTime <= turn.leadTurnStartTime + turn.turnDuration) {
                inTurn = true;
                turnData = turn;
                break;
              }
            }
            
            let intermediatePosition;
            if (inTurn && turnData) {
              // Calculate physics-based curved path during banked turn
              const turnProgress = (intermediateTime - turnData.leadTurnStartTime) / turnData.turnDuration;
              const clampedProgress = Math.max(0, Math.min(1, turnProgress));
              
              // Physics-based turn radius calculation: R = V²/(11.26 × tan(bank_angle))
              const speedKnots = 250; // Current flight speed in knots
              const headingChangeDegrees = Math.abs(Cesium.Math.toDegrees(turnData.headingChange));
              
              // Calculate bank angle based on turn intensity (more realistic than arbitrary values)
              let bankAngleDegrees;
              if (turnData.totalTurnPhases === 2) {
                // Two-phase turn: maintain higher banking for smoother turns
                bankAngleDegrees = turnData.isFirstPhase ? 45 : Math.max(30, headingChangeDegrees * 0.6);
              } else {
                // Single-phase turn: bank angle proportional to turn intensity
                if (headingChangeDegrees <= 15) {
                  bankAngleDegrees = 15; // Shallow turns
                } else if (headingChangeDegrees <= 45) {
                  bankAngleDegrees = 30; // Standard turns
                } else {
                  bankAngleDegrees = 45; // Steep turns
                }
              }
              
              // Calculate turn radius using aviation physics formula: R = V²/(11.26 × tan(θ))
              const bankAngleRadians = Cesium.Math.toRadians(bankAngleDegrees);
              const turnRadiusNM = (speedKnots * speedKnots) / (11.26 * Math.tan(bankAngleRadians));
              const turnRadiusMeters = turnRadiusNM * 1852; // Convert nautical miles to meters
              
              // Alternative physics formula: R = V²/(g × tan(θ)) for cross-validation
              const speedMs = speedKnots * 0.514444; // Convert knots to m/s
              const g = 9.81; // gravitational acceleration
              const turnRadiusPhysics = (speedMs * speedMs) / (g * Math.tan(bankAngleRadians));
              
              // Use the aviation-specific formula (typically gives larger, more realistic radii)
              const actualTurnRadius = turnRadiusMeters;
              
              // Calculate turn center point perpendicular to inbound course
              const currentCart = Cesium.Cartographic.fromCartesian(currentWP.position);
              const nextCart = Cesium.Cartographic.fromCartesian(nextWP.position);
              
              // Calculate inbound course bearing
              const inboundBearing = Math.atan2(
                Math.sin(nextCart.longitude - currentCart.longitude) * Math.cos(nextCart.latitude),
                Math.cos(currentCart.latitude) * Math.sin(nextCart.latitude) - 
                Math.sin(currentCart.latitude) * Math.cos(nextCart.latitude) * Math.cos(nextCart.longitude - currentCart.longitude)
              );
              
              // Determine turn center direction (90° perpendicular to inbound course)
              const turnDirection = Math.sign(turnData.headingChange);
              const centerBearing = inboundBearing + (turnDirection * Math.PI / 2);
              
              // Calculate turn center position
              const centerDistanceFromStart = actualTurnRadius * Math.sin(Math.abs(turnData.headingChange) / 2);
              const centerLat = currentCart.latitude + (centerDistanceFromStart * Math.cos(centerBearing)) / 111000;
              const centerLon = currentCart.longitude + (centerDistanceFromStart * Math.sin(centerBearing)) / (111000 * Math.cos(currentCart.latitude));
              
              // Calculate aircraft position on the circular arc
              const currentAngle = turnData.headingChange * clampedProgress;
              const arcBearing = centerBearing - (turnDirection * Math.PI / 2) + currentAngle;
              
              const arcLat = centerLat + (actualTurnRadius * Math.cos(arcBearing)) / 111000;
              const arcLon = centerLon + (actualTurnRadius * Math.sin(arcBearing)) / (111000 * Math.cos(centerLat));
              
              intermediatePosition = Cesium.Cartesian3.fromDegrees(
                Cesium.Math.toDegrees(arcLon),
                Cesium.Math.toDegrees(arcLat),
                currentCart.height + (nextCart.height - currentCart.height) * factor
              );
              
              // Store calculated bank angle for orientation property
              turnData.calculatedBankAngle = bankAngleDegrees;
              
            } else {
              // Straight line interpolation when not turning
              intermediatePosition = new Cesium.Cartesian3();
              Cesium.Cartesian3.lerp(currentWP.position, nextWP.position, factor, intermediatePosition);
            }
            
            enhancedFlightData.push({
              time: intermediateTime,
              position: intermediatePosition,
              heading: currentWP.heading + (nextWP.heading - currentWP.heading) * factor,
              pitch: currentWP.pitch + (nextWP.pitch - currentWP.pitch) * factor,
              roll: 0 // Will be calculated by orientation property
            });
          }
        }
        
        // Add final waypoint
        enhancedFlightData.push(flightData[flightData.length - 1]);
        
        // Create position property with enhanced flight path
        const positionProperty = new Cesium.SampledPositionProperty();
        for (let i = 0; i < enhancedFlightData.length; i++) {
          positionProperty.addSample(
            Cesium.JulianDate.fromDate(new Date(enhancedFlightData[i].time)), 
            enhancedFlightData[i].position
          );
        }
        
        positionProperty.setInterpolationOptions({
          interpolationDegree: 1, // Linear interpolation for smoother curves
          interpolationAlgorithm: Cesium.LinearApproximation
        });

        // Create dynamic orientation using CallbackProperty with lead-turning
        const orientationProperty = new Cesium.CallbackProperty((time, result) => {
          const currentTime = Cesium.JulianDate.toDate(time).getTime();
          let flightPoint = flightData[0];
          
          // Find current position in flight plan
          for (let i = 1; i < flightData.length; i++) {
            if (currentTime <= flightData[i].time) {
              const t1 = flightData[i - 1].time;
              const t2 = flightData[i].time;
              const factor = (currentTime - t1) / (t2 - t1);
              
              const h1 = flightData[i - 1].heading;
              const h2 = flightData[i].heading;
              const p1 = flightData[i - 1].pitch;
              const p2 = flightData[i].pitch;
              
              // Check if we're in a lead-turn
              let inTurn = false;
              let turnData = null;
              
              for (const turn of leadTurnData) {
                if (currentTime >= turn.leadTurnStartTime && 
                    currentTime <= turn.leadTurnStartTime + turn.turnDuration) {
                  inTurn = true;
                  turnData = turn;
                  break;
                }
              }
              
              let dynamicHeading, dynamicRoll;
              
              if (inTurn && turnData) {
                // We're in a lead-turn - turn to the outbound course
                const targetHeading = turnData.outboundCourse;
                const startHeading = turnData.inboundCourse;
                const headingChange = turnData.headingChange;
                
                // Calculate turn progress
                const turnProgress = (currentTime - turnData.leadTurnStartTime) / turnData.turnDuration;
                const clampedProgress = Math.max(0, Math.min(1, turnProgress));
                
                // Linear progression toward outbound course (no overshoot)
                dynamicHeading = startHeading + headingChange * clampedProgress;
                
                // Ensure we NEVER overshoot the outbound course
                if (Math.abs(headingChange) > 0) {
                  if (headingChange > 0) {
                    // Right turn - don't exceed outbound course
                    dynamicHeading = Math.min(dynamicHeading, targetHeading);
                  } else {
                    // Left turn - don't exceed outbound course
                    dynamicHeading = Math.max(dynamicHeading, targetHeading);
                  }
                }
                
                // Normalize dynamic heading
                while (dynamicHeading > Math.PI) dynamicHeading -= 2 * Math.PI;
                while (dynamicHeading < -Math.PI) dynamicHeading += 2 * Math.PI;
                
                // Calculate how much of the turn we've completed
                let actualHeadingChange = dynamicHeading - startHeading;
                while (actualHeadingChange > Math.PI) actualHeadingChange -= 2 * Math.PI;
                while (actualHeadingChange < -Math.PI) actualHeadingChange += 2 * Math.PI;
                
                const headingProgress = Math.abs(actualHeadingChange / headingChange);
                const clampedHeadingProgress = Math.max(0, Math.min(1, headingProgress));
                
                // Banking synchronized with heading progress
                let bankingFactor;
                if (clampedHeadingProgress <= 0.5) {
                  // First half of turn: build banking
                  bankingFactor = Math.sin(clampedHeadingProgress * Math.PI); // 0 to 1
                } else {
                  // Second half of turn: decrease banking to zero
                  bankingFactor = Math.sin((1 - clampedHeadingProgress) * Math.PI); // 1 to 0
                }
                
                // Use physics-based banking calculated during position interpolation
                let bankAngleDegrees;
                if (turnData.calculatedBankAngle) {
                  // Use the bank angle calculated from physics-based turn radius
                  bankAngleDegrees = turnData.calculatedBankAngle;
                } else {
                  // Fallback to intensity-based banking for backward compatibility
                  let turnIntensity = Math.abs(Cesium.Math.toDegrees(headingChange));
                  
                  // For two-step turns, maintain consistent banking between phases
                  if (turnData.totalTurnPhases === 2) {
                    if (turnData.isFirstPhase) {
                      bankAngleDegrees = 45; // First 89° turn - use full banking
                    } else if (turnData.isSecondPhase) {
                      // Remaining turn - continue with appropriate banking
                      bankAngleDegrees = Math.max(turnIntensity * 0.6, 30);
                    }
                  } else {
                    bankAngleDegrees = Math.min(turnIntensity, 60);
                  }
                }
                
                const maxBankAngle = Cesium.Math.toRadians(bankAngleDegrees);
                dynamicRoll = Math.sign(headingChange) * maxBankAngle * bankingFactor;
                
                // Stop turning when we reach the outbound course
                const headingDifference = Math.abs(dynamicHeading - targetHeading);
                if (headingDifference < 0.01) { // Within ~0.5 degrees
                  dynamicRoll = 0;
                  dynamicHeading = targetHeading;
                }
                
              } else {
                // Not in turn - fly straight on current leg's course
                // Find which leg we're on and use its course
                dynamicHeading = h1;
                dynamicRoll = 0;
                
                // If we're between waypoints, use the direct course between them
                for (let j = 0; j < this.waypoints.length - 1; j++) {
                  const legStart = flightData[j];
                  const legEnd = flightData[j + 1];
                  
                  if (currentTime >= legStart.time && currentTime <= legEnd.time) {
                    // Calculate direct course for this leg
                    const startWP = this.waypoints[j];
                    const endWP = this.waypoints[j + 1];
                    
                    const startCart = Cesium.Cartographic.fromDegrees(startWP.longitude, startWP.latitude);
                    const endCart = Cesium.Cartographic.fromDegrees(endWP.longitude, endWP.latitude);
                    
                    const deltaLon = endCart.longitude - startCart.longitude;
                    const y = Math.sin(deltaLon) * Math.cos(endCart.latitude);
                    const x = Math.cos(startCart.latitude) * Math.sin(endCart.latitude) - 
                             Math.sin(startCart.latitude) * Math.cos(endCart.latitude) * Math.cos(deltaLon);
                    
                    dynamicHeading = Math.atan2(y, x);
                    break;
                  }
                }
              }
              
              flightPoint = {
                heading: dynamicHeading,
                pitch: p1 + (p2 - p1) * factor,
                roll: dynamicRoll,
                position: flightData[i - 1].position
              };
              break;
            }
            flightPoint = flightData[i];
          }
          
          // Convert from geographic to Cesium coordinate system
          const cesiumHeading = flightPoint.heading - Math.PI / 2; // Subtract 90 degrees
          
          // Create quaternion from heading, pitch, roll
          return Cesium.Transforms.headingPitchRollQuaternion(
            flightPoint.position,
            new Cesium.HeadingPitchRoll(cesiumHeading, flightPoint.pitch, flightPoint.roll),
            Cesium.Ellipsoid.WGS84,
            Cesium.Transforms.eastNorthUpToFixedFrame,
            result
          );
        }, false);

        // Apply to entity
        this.entity.position = positionProperty;
        this.entity.orientation = orientationProperty;
        
        // Update flight plan status
        this.flightPlan = `Flying (${this.waypoints.length} waypoints)`;
      }

      stopFlight() {
        this.isFlying = false;
        this.flightProgress = 0;
        this.flightStartTime = null;
        
        // Reset flight data
        if (this.originalFuel !== undefined) {
          this.fuel = `${this.originalFuel}%`;
          this.originalFuel = undefined;
        }
        this.timeOnStation = '0m 0s';
        this.status = 'Active';
        this.speed = 0;
        
        // Reset to original position and orientation
        const position = Cesium.Cartesian3.fromDegrees(
          this.longitude,
          this.latitude,
          this.altitude
        );
        
        // Convert from true north (0° = north) to Cesium system (0° = east)
        const cesiumHeading = this.heading - 90;
        const headingRadians = Cesium.Math.toRadians(cesiumHeading);
        const pitchRadians = Cesium.Math.toRadians(this.pitch);
        const rollRadians = Cesium.Math.toRadians(this.roll);
        const hpr = new Cesium.HeadingPitchRoll(headingRadians, pitchRadians, rollRadians);
        const orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);
        
        this.entity.position = position;
        this.entity.orientation = orientation;
        this.flightPlan = `Planned (${this.waypoints.length} waypoints)`;
      }

      calculateTotalDistance() {
        let totalDistance = 0;
        for (let i = 1; i < this.waypoints.length; i++) {
          const prev = this.waypoints[i - 1];
          const curr = this.waypoints[i];
          
          const distance = Cesium.Cartesian3.distance(
            Cesium.Cartesian3.fromDegrees(prev.longitude, prev.latitude, prev.altitude),
            Cesium.Cartesian3.fromDegrees(curr.longitude, curr.latitude, curr.altitude)
          );
          
          totalDistance += distance;
        }
        return totalDistance / 1852; // Convert to nautical miles
      }

      clearFlightPlan() {
        this.stopFlight();
        this.waypoints = [];
        if (this.flightPath) {
          viewer.entities.remove(this.flightPath);
          this.flightPath = null;
        }
        this.flightPlan = 'None';
      }

      remove() {
        if (this.entity) {
          viewer.entities.remove(this.entity);
        }
        if (this.flightPath) {
          viewer.entities.remove(this.flightPath);
        }
      }
    }

    // Object card HTML generation
    function createObjectCard(obj) {
      // Get country-specific styling
      const countryStyle = getCountryStyle(obj.country);
      
      return `
        <div class="object-card" id="card_${obj.id}" data-object-id="${obj.id}">
          <div class="object-card-header" onclick="toggleCard(${obj.id})">
            <h4 style="color: ${countryStyle.fontColor};">
              ${obj.callsign} (${obj.type})
              <span style="font-size: 12px; color: #aaa;">#${obj.id}</span>
            </h4>
            <div class="caret" id="caret_${obj.id}"></div>
          </div>
          <div class="object-card-content" id="content_${obj.id}">
          
          <div class="object-info">
            <div>
              <label>Country:</label>
              <input class="editable" value="${obj.country}" onchange="updateObjectField(${obj.id}, 'country', this.value)">
            </div>
            <div>
              <label>Platform:</label>
              <span>${obj.platform}</span>
            </div>
            <div>
              <label>Longitude:</label>
              <span class="longitude">${obj.longitude.toFixed(6)}°</span>
            </div>
            <div>
              <label>Latitude:</label>
              <span class="latitude">${obj.latitude.toFixed(6)}°</span>
            </div>
            <div>
              <label>Speed:</label>
              <span class="speed">${obj.speed.toFixed(0)} kts</span>
            </div>
            <div>
              <label>Altitude:</label>
              <span class="altitude">${(obj.altitude * 3.28084).toFixed(0)} ft</span>
            </div>
            <div>
              <label>Heading:</label>
              <span class="heading">${obj.heading.toFixed(0)}°</span>
            </div>
            <div>
              <label>Pitch:</label>
              <span class="pitch">${obj.pitch.toFixed(1)}°</span>
            </div>
            <div>
              <label>Bank:</label>
              <span class="roll">${obj.roll.toFixed(1)}°</span>
            </div>
            <div>
              <label>Fuel:</label>
              <input class="editable" value="${obj.fuel}" onchange="updateObjectField(${obj.id}, 'fuel', this.value)">
            </div>
            <div>
              <label>Time on Station:</label>
              <input class="editable" value="${obj.timeOnStation}" onchange="updateObjectField(${obj.id}, 'timeOnStation', this.value)">
            </div>
            <div>
              <label>Status:</label>
              <input class="editable" value="${obj.status}" onchange="updateObjectField(${obj.id}, 'status', this.value)">
            </div>
            <div>
              <label>Mission:</label>
              <input class="editable" value="${obj.mission}" onchange="updateObjectField(${obj.id}, 'mission', this.value)">
            </div>
            <div>
              <label>Task:</label>
              <input class="editable" value="${obj.task}" onchange="updateObjectField(${obj.id}, 'task', this.value)">
            </div>
            <div>
              <label>Loadout:</label>
              <input class="editable" value="${obj.loadout}" onchange="updateObjectField(${obj.id}, 'loadout', this.value)">
            </div>
            <div style="grid-column: span 2;">
              <label>Flight Plan:</label>
              <input class="editable" style="width: 150px;" value="${obj.flightPlan}" onchange="updateObjectField(${obj.id}, 'flightPlan', this.value)">
            </div>
          </div>

          <div class="object-controls">
            <button class="btn" onclick="focusObject(${obj.id})">Focus</button>
            <button class="btn" onclick="trackObject(${obj.id})">Track</button>
            <button class="btn" onclick="duplicateObject(${obj.id})">Duplicate</button>
            <button class="btn" onclick="saveObject(${obj.id})">Save</button>
            <button class="btn danger" onclick="removeObject(${obj.id})">Remove</button>
          </div>

          <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #555;">
            <div style="color: #ff6b6b; font-size: 11px; margin-bottom: 8px;">🔧 DEBUG CONTROLS</div>
            <div class="object-controls">
              <button class="btn" style="background: #ff6b6b;" onclick="testBankAngle(${obj.id})">Bank 30°</button>
              <button class="btn" style="background: #4ecdc4;" onclick="testAltitude(${obj.id})">Alt 30K ft</button>
              <button class="btn" style="background: #45b7d1;" onclick="testReset(${obj.id})">Reset</button>
            </div>
          </div>

          <div class="flight-planning">
            <div class="flight-controls">
              <button class="btn ${obj.isPlanning ? 'danger' : ''}" onclick="toggleFlightPlanning(${obj.id})">
                ${obj.isPlanning ? 'Stop Planning' : 'Plan Flight'}
              </button>
              ${obj.waypoints.length >= 2 ? `
                <button class="btn" onclick="${obj.isFlying ? 'stopFlight' : 'startFlight'}(${obj.id})">
                  ${obj.isFlying ? 'Stop Flight' : 'Start Flight'}
                </button>
              ` : ''}
              ${obj.waypoints.length > 0 ? `
                <button class="btn-small danger" onclick="clearFlightPlan(${obj.id})">Clear</button>
              ` : ''}
              <span class="flight-status">${obj.isFlying ? 'FLYING' : obj.isPlanning ? 'PLANNING' : 'READY'}</span>
            </div>
            
            ${obj.waypoints.length > 0 ? `
              <div class="waypoint-list">
                ${obj.waypoints.map((wp, index) => `
                  <div class="waypoint-item">
                    <div style="flex: 1;">
                      <div style="color: #4a9eff; font-family: 'Courier New', monospace; font-size: 11px; margin-bottom: 4px;">
                        WP${index + 1}: ${wp.longitude.toFixed(4)}°, ${wp.latitude.toFixed(4)}°
                      </div>
                      <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; margin-bottom: 2px;">
                        <div style="display: flex; align-items: center; gap: 2px;">
                          <span style="color: #aaa; font-size: 10px;">Alt:</span>
                          <input class="editable" style="width: 45px; font-size: 10px;" 
                                 value="${(wp.altitude * 3.28084).toFixed(0)}" 
                                 onchange="updateWaypointAltitude(${obj.id}, ${wp.id}, this.value)"
                                 placeholder="ft">
                          <span style="color: #aaa; font-size: 9px;">ft</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 2px;">
                          <span style="color: #aaa; font-size: 10px;">Spd:</span>
                          <input class="editable" style="width: 45px; font-size: 10px;" 
                                 value="${wp.speed || obj.flightSpeed || 250}" 
                                 onchange="updateWaypointSpeed(${obj.id}, ${wp.id}, this.value)"
                                 placeholder="kts">
                          <span style="color: #aaa; font-size: 9px;">kt</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 2px;">
                          <span style="color: #aaa; font-size: 10px;">Hdg:</span>
                          <input class="editable" style="width: 45px; font-size: 10px;" 
                                 value="${wp.heading !== undefined ? wp.heading.toFixed(0) : 'Auto'}" 
                                 onchange="updateWaypointHeading(${obj.id}, ${wp.id}, this.value)"
                                 placeholder="deg">
                          <span style="color: #aaa; font-size: 9px;">°</span>
                        </div>
                      </div>
                    </div>
                    <div class="waypoint-controls">
                      <button class="btn-small danger" onclick="removeWaypoint(${obj.id}, ${wp.id})">×</button>
                    </div>
                  </div>
                `).join('')}
              </div>
            ` : ''}
          </div>
          </div>
        </div>
      `;
    }

    // Object management functions
    function addObject(type, modelUrl, platform) {
      // Prompt for initial heading
      const headingInput = prompt(`Enter initial heading for ${type} (0-360 degrees):`, Math.floor(Math.random() * 360));
      let initialHeading = null;
      
      if (headingInput !== null) {
        const heading = parseFloat(headingInput);
        if (!isNaN(heading)) {
          initialHeading = ((heading % 360) + 360) % 360; // Normalize to 0-360
        }
      }
      
      const obj = new TrackedObject(type, modelUrl, platform, initialHeading);
      objects.push(obj);
      updateObjectCards();
    }

    function removeObject(id) {
      const index = objects.findIndex(obj => obj.id === id);
      if (index !== -1) {
        objects[index].remove();
        objects.splice(index, 1);
        updateObjectCards();
      }
    }

    function duplicateObject(id) {
      const original = objects.find(obj => obj.id === id);
      if (original) {
        addObject(original.type, original.modelUrl, original.platform);
      }
    }

    function focusObject(id) {
      const obj = objects.find(obj => obj.id === id);
      if (obj && obj.entity) {
        viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(
            obj.longitude,
            obj.latitude,
            obj.altitude + 5000
          )
        });
      }
    }

    function trackObject(id) {
      const obj = objects.find(obj => obj.id === id);
      if (obj && obj.entity) {
        viewer.trackedEntity = obj.entity;
      }
    }

    function updateObjectField(id, field, value) {
      const obj = objects.find(obj => obj.id === id);
      if (obj) {
        obj[field] = value;
        if (field === 'callsign' && obj.entity) {
          obj.entity.name = value;
        }
      }
    }

    function updateObjectCards() {
      const container = document.getElementById('object-cards-container');
      container.innerHTML = objects.map(obj => createObjectCard(obj)).join('');
    }

    // Update only dynamic data without regenerating HTML (prevents input field resets)
    function updateObjectData() {
      objects.forEach(obj => {
        const card = document.querySelector(`[data-object-id="${obj.id}"]`);
        if (!card) return;

        // Update span elements (display data)
        const updateSpan = (selector, value) => {
          const element = card.querySelector(selector);
          if (element && element.tagName === 'SPAN') {
            element.textContent = value;
          }
        };

        // Update input elements (only if not focused by user)
        const updateInput = (selector, value) => {
          const element = card.querySelector(selector);
          if (element && element.tagName === 'INPUT' && !element.matches(':focus')) {
            element.value = value;
          }
        };

        // Update real-time flight data (spans)
        updateSpan('.longitude', obj.longitude.toFixed(6) + '°');
        updateSpan('.latitude', obj.latitude.toFixed(6) + '°');
        updateSpan('.altitude', (obj.altitude * 3.28084).toFixed(0) + ' ft');
        updateSpan('.speed', obj.speed.toFixed(0) + ' kts');
        updateSpan('.heading', obj.heading.toFixed(0) + '°');
        updateSpan('.pitch', obj.pitch.toFixed(1) + '°');
        updateSpan('.roll', obj.roll.toFixed(1) + '°');

        // Update editable fields (inputs) - only when not being edited
        const fuelInput = card.querySelector('input[onchange*="fuel"]');
        if (fuelInput && !fuelInput.matches(':focus')) {
          fuelInput.value = obj.fuel;
        }
        
        const timeInput = card.querySelector('input[onchange*="timeOnStation"]');
        if (timeInput && !timeInput.matches(':focus')) {
          timeInput.value = obj.timeOnStation;
        }
        
        const statusInput = card.querySelector('input[onchange*="status"]');
        if (statusInput && !statusInput.matches(':focus')) {
          statusInput.value = obj.status;
        }

        // NEVER update flight plan inputs to prevent editing issues
        // Flight plan waypoint inputs are managed separately and should not be refreshed
      });
    }

    // Real-time updates
    function updateObjects() {
      objects.forEach(obj => {
        obj.updateCalculatedFields();
      });
      updateObjectData(); // Only update data, not full HTML regeneration
    }

    // Update more frequently for real-time flight data
    // Check if any aircraft are flying and adjust update rate accordingly
    function getUpdateInterval() {
      const anyFlying = objects.some(obj => obj.isFlying);
      return anyFlying ? 200 : 1000; // 5 FPS when flying, 1 FPS when static
    }

    // Start with base interval
    let updateIntervalId = setInterval(updateObjects, 1000);

    // Dynamic update rate adjustment
    function adjustUpdateRate() {
      clearInterval(updateIntervalId);
      updateIntervalId = setInterval(updateObjects, getUpdateInterval());
    }

    // Check and adjust update rate every 2 seconds
    setInterval(adjustUpdateRate, 2000);

    // Aircraft types configuration
    const aircraftTypes = [
      {
        text: "F-35 Lightning II",
        platform: "Fighter",
        modelUrl: "assets/f-35b_lightning_ii.glb"
      },
      {
        text: "J-20 Mighty Dragon",
        platform: "Fighter", 
        modelUrl: "assets/chengdu_j-20_fighter_v2.glb"
      },
      {
        text: "Test Box",
        platform: "Test",
        modelUrl: "../SampleData/models/BoxInstanced/BoxInstanced.gltf"
      }
    ];

    // Setup dropdown
    const modelSelect = document.getElementById('modelSelect');
    aircraftTypes.forEach((aircraft, index) => {
      const option = document.createElement('option');
      option.value = index;
      option.text = aircraft.text;
      modelSelect.appendChild(option);
    });

    modelSelect.addEventListener('change', function() {
      const selectedIndex = parseInt(this.value);
      if (!isNaN(selectedIndex) && aircraftTypes[selectedIndex]) {
        const aircraft = aircraftTypes[selectedIndex];
        addObject(aircraft.text, aircraft.modelUrl, aircraft.platform);
        this.value = ''; // Reset selection
      }
    });

    // Flight planning global variables
    let currentPlanningObject = null;
    let waypointPreviewPoint = null;

    // Flight planning functions
    function toggleFlightPlanning(id) {
      const obj = objects.find(obj => obj.id === id);
      if (!obj) return;

      if (obj.isPlanning) {
        // Stop planning mode
        obj.isPlanning = false;
        currentPlanningObject = null;
        document.getElementById(`card_${id}`).classList.remove('planning-mode');
        
        // Hide waypoint preview point
        if (waypointPreviewPoint) {
          waypointPreviewPoint.show = false;
        }
      } else {
        // Stop any other object's planning mode
        objects.forEach(o => {
          o.isPlanning = false;
          document.getElementById(`card_${o.id}`)?.classList.remove('planning-mode');
        });
        
        // Start planning mode
        obj.isPlanning = true;
        currentPlanningObject = obj;
        document.getElementById(`card_${id}`).classList.add('planning-mode');
        
        // Enable waypoint preview point (will be shown on first mouse move)
        if (waypointPreviewPoint) {
          waypointPreviewPoint.show = false; // Will be shown when mouse moves over terrain
        }
      }
      
      updateObjectCards();
    }

    function startFlight(id) {
      const obj = objects.find(obj => obj.id === id);
      if (obj) {
        obj.startFlight();
        updateObjectCards();
      }
    }

    function stopFlight(id) {
      const obj = objects.find(obj => obj.id === id);
      if (obj) {
        obj.stopFlight();
        updateObjectCards();
      }
    }

    function clearFlightPlan(id) {
      const obj = objects.find(obj => obj.id === id);
      if (obj) {
        obj.clearFlightPlan();
        updateObjectCards();
      }
    }

    function removeWaypoint(objectId, waypointId) {
      const obj = objects.find(obj => obj.id === objectId);
      if (obj) {
        obj.removeWaypoint(waypointId);
        updateObjectCards();
      }
    }

    function updateFlightSpeed(id, newSpeed) {
      const obj = objects.find(obj => obj.id === id);
      if (obj) {
        obj.flightSpeed = parseFloat(newSpeed) || 250;
      }
    }

    function updateHeading(id, newHeading) {
      const obj = objects.find(obj => obj.id === id);
      if (obj) {
        let heading = parseFloat(newHeading) || 0;
        // Normalize heading to 0-360 degrees
        heading = ((heading % 360) + 360) % 360;
        obj.heading = heading;
        
        // Update entity orientation if not flying
        if (!obj.isFlying && obj.entity) {
          const position = Cesium.Cartesian3.fromDegrees(
            obj.longitude,
            obj.latitude,
            obj.altitude
          );
          
          // Convert from true north (0° = north) to Cesium system (0° = east)
          const cesiumHeading = obj.heading - 90;
          const headingRadians = Cesium.Math.toRadians(cesiumHeading);
          const pitchRadians = Cesium.Math.toRadians(obj.pitch);
          const rollRadians = Cesium.Math.toRadians(obj.roll);
          const hpr = new Cesium.HeadingPitchRoll(headingRadians, pitchRadians, rollRadians);
          const orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);
          
          obj.entity.orientation = orientation;
        }
      }
    }

    function updateWaypointAltitude(objectId, waypointId, newAltitudeFeet) {
      const obj = objects.find(obj => obj.id === objectId);
      if (obj) {
        const waypoint = obj.waypoints.find(wp => wp.id === waypointId);
        if (waypoint) {
          // Convert feet to meters
          waypoint.altitude = (parseFloat(newAltitudeFeet) || 10000) / 3.28084;
          obj.updateFlightPath();
        }
      }
    }

    function updateWaypointSpeed(objectId, waypointId, newSpeed) {
      const obj = objects.find(obj => obj.id === objectId);
      if (obj) {
        const waypoint = obj.waypoints.find(wp => wp.id === waypointId);
        if (waypoint) {
          waypoint.speed = parseFloat(newSpeed) || 250; // Default to 250 knots
          obj.updateFlightPath();
        }
      }
    }

    function updateWaypointHeading(objectId, waypointId, newHeading) {
      const obj = objects.find(obj => obj.id === objectId);
      if (obj) {
        const waypoint = obj.waypoints.find(wp => wp.id === waypointId);
        if (waypoint) {
          if (newHeading === 'Auto' || newHeading === '' || isNaN(parseFloat(newHeading))) {
            waypoint.heading = undefined; // Auto-calculate
          } else {
            waypoint.heading = parseFloat(newHeading);
          }
          obj.updateFlightPath();
        }
      }
    }

    // DEBUG FUNCTIONS for testing orientation and position changes
    function testBankAngle(id) {
      const obj = objects.find(obj => obj.id === id);
      if (obj && obj.entity) {
        console.log('Testing bank angle for object', id);
        
        // Update object data
        obj.roll = 30;
        
        // Get current position
        const position = Cesium.Cartesian3.fromDegrees(
          obj.longitude,
          obj.latitude,
          obj.altitude
        );
        
        // Create new orientation with 30 degree bank
        const cesiumHeading = obj.heading - 90; // Convert to Cesium coordinates
        const headingRadians = Cesium.Math.toRadians(cesiumHeading);
        const pitchRadians = Cesium.Math.toRadians(obj.pitch);
        const rollRadians = Cesium.Math.toRadians(30); // 30 degree bank
        
        const hpr = new Cesium.HeadingPitchRoll(headingRadians, pitchRadians, rollRadians);
        const orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);
        
        // Apply directly to entity
        obj.entity.orientation = orientation;
        
        console.log('Applied 30° bank angle to entity');
        updateObjectCards();
      }
    }

    function testAltitude(id) {
      const obj = objects.find(obj => obj.id === id);
      if (obj && obj.entity) {
        console.log('Testing altitude change for object', id);
        
        // Update object data
        const newAltitudeFeet = 30000;
        const newAltitudeMeters = newAltitudeFeet / 3.28084;
        obj.altitude = newAltitudeMeters;
        
        // Create new position at 30,000 feet
        const position = Cesium.Cartesian3.fromDegrees(
          obj.longitude,
          obj.latitude,
          newAltitudeMeters
        );
        
        // Apply directly to entity
        obj.entity.position = position;
        
        console.log('Changed altitude to 30,000 feet');
        updateObjectCards();
      }
    }

    function testReset(id) {
      const obj = objects.find(obj => obj.id === id);
      if (obj && obj.entity) {
        console.log('Resetting object to original state', id);
        
        // Reset object data
        obj.roll = 0;
        obj.pitch = 0;
        
        // Reset to original position and orientation
        const position = Cesium.Cartesian3.fromDegrees(
          obj.longitude,
          obj.latitude,
          obj.altitude
        );
        
        const cesiumHeading = obj.heading - 90;
        const headingRadians = Cesium.Math.toRadians(cesiumHeading);
        const pitchRadians = Cesium.Math.toRadians(0);
        const rollRadians = Cesium.Math.toRadians(0);
        
        const hpr = new Cesium.HeadingPitchRoll(headingRadians, pitchRadians, rollRadians);
        const orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);
        
        obj.entity.position = position;
        obj.entity.orientation = orientation;
        
        console.log('Reset object to original state');
        updateObjectCards();
      }
    }

    // Create waypoint preview point
    function createWaypointPreviewPoint() {
      if (waypointPreviewPoint) {
        viewer.entities.remove(waypointPreviewPoint);
      }
      
      waypointPreviewPoint = viewer.entities.add({
        id: 'waypoint_preview',
        name: 'Next Waypoint Preview',
        position: Cesium.Cartesian3.fromDegrees(0, 0, 0), // Will be updated on mouse move
        point: {
          pixelSize: 12,
          color: Cesium.Color.YELLOW.withAlpha(0.8),
          outlineColor: Cesium.Color.BLACK,
          outlineWidth: 2,
          heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
          disableDepthTestDistance: Number.POSITIVE_INFINITY
        },
        label: {
          text: 'Next Waypoint',
          font: '12pt sans-serif',
          fillColor: Cesium.Color.YELLOW,
          outlineColor: Cesium.Color.BLACK,
          outlineWidth: 2,
          style: Cesium.LabelStyle.FILL_AND_OUTLINE,
          pixelOffset: new Cesium.Cartesian2(0, -30),
          disableDepthTestDistance: Number.POSITIVE_INFINITY
        },
        show: false // Initially hidden
      });
    }

    // Mouse move handler for waypoint preview
    viewer.cesiumWidget.canvas.addEventListener('mousemove', function(e) {
      if (!currentPlanningObject || !waypointPreviewPoint) return;

      const pick = viewer.camera.getPickRay(new Cesium.Cartesian2(e.clientX, e.clientY));
      const pickedPosition = viewer.scene.globe.pick(pick, viewer.scene);
      
      if (pickedPosition) {
        // Update preview point position at ground level (zero altitude)
        const cartographic = Cesium.Cartographic.fromCartesian(pickedPosition);
        const longitude = Cesium.Math.toDegrees(cartographic.longitude);
        const latitude = Cesium.Math.toDegrees(cartographic.latitude);
        
        // Set position at zero altitude (ground level)
        waypointPreviewPoint.position = Cesium.Cartesian3.fromDegrees(longitude, latitude, 0);
        waypointPreviewPoint.show = true;
        
        // Update label with coordinates
        waypointPreviewPoint.label.text = `Next WP: ${longitude.toFixed(4)}°, ${latitude.toFixed(4)}°`;
      } else {
        waypointPreviewPoint.show = false;
      }
    }, false);

    // Click handler for waypoint creation
    viewer.cesiumWidget.canvas.addEventListener('click', function(e) {
      if (!currentPlanningObject) return;

      const pick = viewer.camera.getPickRay(new Cesium.Cartesian2(e.clientX, e.clientY));
      const pickedPosition = viewer.scene.globe.pick(pick, viewer.scene);
      
      if (pickedPosition) {
        const cartographic = Cesium.Cartographic.fromCartesian(pickedPosition);
        const longitude = Cesium.Math.toDegrees(cartographic.longitude);
        const latitude = Cesium.Math.toDegrees(cartographic.latitude);
        const altitude = 0; // Start at 0 altitude

        currentPlanningObject.addWaypoint(longitude, latitude, altitude);
        updateObjectCards();
      }
    }, false);

    // Initialize waypoint preview point
    createWaypointPreviewPoint();

    // Global flight control functions
    function startAllFlights() {
      objects.forEach(obj => {
        if (obj.waypoints.length >= 2 && !obj.isFlying) {
          obj.startFlight();
        }
      });
      updateObjectCards();
    }

    function stopAllFlights() {
      objects.forEach(obj => {
        if (obj.isFlying) {
          obj.stopFlight();
        }
      });
      updateObjectCards();
    }

    // Card toggle functionality
    function toggleCard(id) {
      const card = document.getElementById(`card_${id}`);
      const content = document.getElementById(`content_${id}`);
      const caret = document.getElementById(`caret_${id}`);
      
      if (content && caret) {
        const isCollapsed = content.classList.contains('collapsed');
        
        if (isCollapsed) {
          // Expand
          content.classList.remove('collapsed');
          caret.classList.remove('collapsed');
          card.classList.remove('collapsed');
        } else {
          // Collapse
          content.classList.add('collapsed');
          caret.classList.add('collapsed');
          card.classList.add('collapsed');
        }
      }
    }

    // Toolbar toggle functionality
    function toggleToolbar() {
      const container = document.getElementById('flight-management-container');
      const toggle = document.getElementById('toolbar-toggle');
      
      if (container.classList.contains('hidden')) {
        container.classList.remove('hidden');
        toggle.textContent = '◀';
      } else {
        container.classList.add('hidden');
        toggle.textContent = '▶';
      }
    }

    // Cesium toolbar toggle functionality
    function toggleCesiumToolbar() {
      const cesiumToolbar = document.querySelector('.cesium-viewer-toolbar');
      const toggle = document.getElementById('cesium-toolbar-toggle');
      
      if (cesiumToolbar.classList.contains('hidden')) {
        cesiumToolbar.classList.remove('hidden');
        toggle.textContent = '◀';
      } else {
        cesiumToolbar.classList.add('hidden');
        toggle.textContent = '▶';
      }
    }

    // Convert object to JSON schema format
    function objectToJSON(obj) {
      return {
        id: obj.id,
        type: obj.type,
        modelUrl: obj.modelUrl,
        platform: obj.platform,
        position: {
          longitude: obj.longitude,
          latitude: obj.latitude,
          altitude: obj.altitude
        },
        orientation: {
          heading: obj.heading,
          pitch: obj.pitch,
          roll: obj.roll
        },
        metadata: {
          callsign: obj.callsign,
          country: obj.country,
          fuel: obj.fuel,
          timeOnStation: obj.timeOnStation,
          loadout: obj.loadout,
          status: obj.status,
          mission: obj.mission,
          task: obj.task
        },
        flightPlan: {
          waypoints: obj.waypoints.map(wp => ({
            longitude: wp.longitude,
            latitude: wp.latitude,
            altitude: wp.altitude,
            speed: wp.speed,
            heading: wp.heading
          })),
          flightSpeed: obj.flightSpeed
        }
      };
    }

    // Save individual object
    function saveObject(id) {
      const obj = objects.find(obj => obj.id === id);
      if (!obj) return;

      const data = {
        version: "1.0",
        timestamp: new Date().toISOString(),
        objects: [objectToJSON(obj)]
      };

      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${obj.callsign}_flight_plan.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Save all objects
    function saveAllObjects() {
      if (objects.length === 0) {
        alert('No objects to save');
        return;
      }

      const data = {
        version: "1.0",
        timestamp: new Date().toISOString(),
        objects: objects.map(obj => objectToJSON(obj))
      };

      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `all_flight_plans_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Trigger file load
    function triggerFileLoad() {
      document.getElementById('load-flight-input').click();
    }

    // Load flight data from JSON file
    function loadFlightData(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = JSON.parse(e.target.result);
          
          // Validate basic structure
          if (!data.objects || !Array.isArray(data.objects)) {
            throw new Error('Invalid file format: missing objects array');
          }

          // Load each object
          data.objects.forEach(objData => {
            const obj = new TrackedObject(objData.type, objData.modelUrl, objData.platform, objData.orientation.heading);
            
            // Set position
            obj.longitude = objData.position.longitude;
            obj.latitude = objData.position.latitude;
            obj.altitude = objData.position.altitude;
            
            // Set orientation
            obj.heading = objData.orientation.heading;
            obj.pitch = objData.orientation.pitch;
            obj.roll = objData.orientation.roll;
            
            // Set metadata
            if (objData.metadata) {
              obj.callsign = objData.metadata.callsign || obj.callsign;
              obj.country = objData.metadata.country || obj.country;
              obj.fuel = objData.metadata.fuel || obj.fuel;
              obj.timeOnStation = objData.metadata.timeOnStation || obj.timeOnStation;
              obj.loadout = objData.metadata.loadout || obj.loadout;
              obj.status = objData.metadata.status || obj.status;
              obj.mission = objData.metadata.mission || obj.mission;
              obj.task = objData.metadata.task || obj.task;
            }
            
            // Set flight plan
            if (objData.flightPlan && objData.flightPlan.waypoints) {
              obj.flightSpeed = objData.flightPlan.flightSpeed || 250;
              objData.flightPlan.waypoints.forEach(wp => {
                obj.addWaypoint(wp.longitude, wp.latitude, wp.altitude);
                // Update last waypoint with speed and heading if provided
                const lastWP = obj.waypoints[obj.waypoints.length - 1];
                if (wp.speed) lastWP.speed = wp.speed;
                if (wp.heading !== undefined) lastWP.heading = wp.heading;
              });
            }
            
            // Update entity position and orientation
            obj.remove();
            obj.createEntity();
            
            objects.push(obj);
          });

          // Redraw all flight paths after loading
          objects.forEach(obj => {
            if (obj.waypoints.length > 1) {
              obj.updateFlightPath();
            }
          });

          updateObjectCards();
          alert(`Loaded ${data.objects.length} object(s) successfully`);

        } catch (error) {
          alert(`Error loading file: ${error.message}`);
        }
      };
      reader.readAsText(file);
      
      // Reset file input
      event.target.value = '';
    }

    // Make functions global for onclick handlers
    window.updateObjectField = updateObjectField;
    window.focusObject = focusObject;
    window.trackObject = trackObject;
    window.duplicateObject = duplicateObject;
    window.removeObject = removeObject;
    window.toggleFlightPlanning = toggleFlightPlanning;
    window.startFlight = startFlight;
    window.stopFlight = stopFlight;
    window.clearFlightPlan = clearFlightPlan;
    window.removeWaypoint = removeWaypoint;
    window.updateFlightSpeed = updateFlightSpeed;
    window.updateHeading = updateHeading;
    window.updateWaypointAltitude = updateWaypointAltitude;
    window.updateWaypointSpeed = updateWaypointSpeed;
    window.updateWaypointHeading = updateWaypointHeading;
    window.testBankAngle = testBankAngle;
    window.testAltitude = testAltitude;
    window.testReset = testReset;
    window.startAllFlights = startAllFlights;
    window.stopAllFlights = stopAllFlights;
    window.toggleCard = toggleCard;
    window.toggleToolbar = toggleToolbar;
    window.toggleCesiumToolbar = toggleCesiumToolbar;
    window.saveObject = saveObject;
    window.saveAllObjects = saveAllObjects;
    window.triggerFileLoad = triggerFileLoad;
    window.loadFlightData = loadFlightData;

  </script>

 </div>

</body>

</html>

